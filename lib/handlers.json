[
  {
    "function": "async (m, { conn, user, budy, isPremium, react, mime, qmsg, reply }) => {\nif (m.chat !== \"120363345101407384@g.us\") {\nif (budy.startsWith(\"https://\") && budy.includes(\"instagram.com\")) {\nif (!m.isGroup && !isPremium) {\nreturn reply('Auto download hanya bisa diakses oleh user premium. Silahkan hubungi owner untuk menjadi premium user atau gunakan di dalam grup untuk free akses.');\n}\ntry {\nconst res = await downloadIG(budy);\n//console.log(res)\nfor (let i of res.data) {\nconn.sendFileUrl(m.chat, i.url, '', m);\n}\n} catch (e) {\nconsole.error(util.format(e));\n}\n} else if (/^(https?:\\/\\/)?(www\\.)?(tiktok\\.com\\/(@[\\w.-]+(\\/video\\/\\d+)?|tag\\/[\\w-]+)|vm\\.tiktok\\.com\\/[\\w/]+|vt\\.tiktok\\.com\\/[\\w/]+)$/.test(budy)) {\nif (!m.isGroup && !isPremium) {\nreturn reply('Auto download hanya bisa diakses oleh user premium. Silahkan hubungi owner untuk menjadi premium user atau gunakan di dalam grup untuk free akses.');\n}\nreact('â³');\ntry {\nlet data = await fetchJson(`https://api.tiklydown.eu.org/api/download?url=${m.text}`);   \nif (data.images) {\nfor (let image of data.images) {\nconn.sendMessage(m.chat, {image:{url:image.url}},{quoted:m})\n}\n} else {\nawait conn.sendMessage(m.chat, {video: { url: data.video.noWatermark }, caption: data.title }, { quoted: global.fake });\nawait conn.sendMessage(m.chat, {audio: {url:data.music.play_url}, mimetype:'audio/mp4', ptt:false},{quoted:m})\n}\nawait react('ðŸš€');\n} catch {\nlet data = await fetchJson(`https://api.tiklydown.eu.org/api/download/v3?url=${m.text}`)\nif (data.result.type === 'image') {\nfor (let image of data.images) {\nawait conn.sendMessage(m.chat, {image:{url:image.url}},{quoted:m})\n}\n} else {\nawait conn.sendMessage(m.chat, {video: { url: data.result.video }, caption: data.result.desc }, { quoted: global.fake });\nawait conn.sendMessage(m.chat, {audio: {url: data.result.music}, mimetype:'audio/mp4', ptt:false},{quoted:m})\n}\n}\n}\n}\n}",
    "on": "message",
    "fromMe": false
  },
  {
    "function": "async(m, {conn, user, isPremium, budy, react, qmsg, reply}) => {\n//if (isPremium && m.quoted && m.quoted.fromMe) {\n//let res = await axios.post('https://chatbot-ji1z.onrender.com/chatbot-ji1z', {\"messages\":[{\"role\":\"system\",\"content\":\"kamu adalah sebuah bot whatsapp, namamu Siesta, nama siesta diambil dari sebuah anime yang berjudul detective already dead, dan itu adalah kamu, kamu di buat untuk memudahkan penggunamu dalam pertanyaan apapun, jawab dengan ramah, jangan lupa gunakan emoji art seperti >////< :D dan lainya, pembuat sekaligus pemilikmu adalah SatzzDev.\"},{\"role\":\"user\",\"content\":budy}]})\n//m.reply(res.data.choices[0].message.content)    \n//}\nif (m.isGroup) {\nconst fvn = { key: { fromMe: false,participant: `0@s.whatsapp.net`, ...(m.chat ? { remoteJid: \"status@broadcast\" } : {}) }, message: { \"audioMessage\": {\"mimetype\":\"audio/ogg; codecs=opus\",\"seconds\": \"86400\",\"ptt\": \"true\"}}}\nlet res = await fetchJson('https://raw.githubusercontent.com/SatzzDev/API/master/data/vn.json'); \nlet audioKey = Object.keys(res).find(key => key === budy.trim());\nif (audioKey) {\nlet audioUrl = res[audioKey].audio;\nconn.sendMessage(m.chat, {audio:{url:audioUrl}, ptt:true, mimetype:'audio/mpeg', waveform: new Uint8Array(64)},{quoted:fvn})\n}\n}\n}",
    "on": "message",
    "fromMe": false
  },
  {
    "function": "async(m, {conn, user, budy, reply}) => {\nlet mentionUser = [...new Set([...(m.mentionedJid || []),...(m.quoted ? [m.quoted.sender] : []),]),];\nfor (let jid of mentionUser) {\nlet user = global.db.data.users[jid];\nif (!user) continue;\nlet afkTime = user.afkTime;\nif (!afkTime || afkTime < 0) continue;\nlet reason = user.afkReason || \"\";\nm.reply(`Jangan tag Dia!,dia sedang AFK ${reason ? \" dengan alasan \" + reason : \"tanpa alasan\"}\\nSelama ${CS(new Date() - afkTime)}`)\n}\nif (db.data.users[m.sender].afkTime > -1) {\nlet user = global.db.data.users[m.sender];\nm.reply(`@${m.sender.split(\"@\")[0]} telah kembali dari AFK ${user.afkReason ? \" setelah \" + user.afkReason : \"\"}\\nSelama ${CS(new Date() - user.afkTime)}`);\nuser.afkTime = -1;\nuser.afkReason = \"\";\n}     \n}",
    "on": "message",
    "fromMe": false
  },
  {
    "function": "async (m, { conn, budy, quoted, reply, isPremium, pushname, itsMe }) => {\n  let room = Object.values(global.db.data.menfess).find(\n    (room) => [room.a, room.b].includes(m.sender) && room.state === \"ACTIVE\"\n  );\n\n  if (\n    !m.key.remoteJid.endsWith(\"@newsletter\") && \n    !room && \n    !itsMe && \n    m.mtype !== 'templateButtonReplyMessage' && \n    m.mtype !== 'interactiveResponseMessage' && \n    budy.length > 1 && \n    !m.isGroup && \n    !budy.startsWith('https://') && \n    !['.', '$', '>'].includes(budy[0])\n  ) {\n    await conn.sendPresenceUpdate(\"composing\", m.chat);\nconst axios = require('axios');\nconst url = `https://generativelanguage.googleapis.com/v1beta/models/gemini-1.5-pro:generateContent?key=AIzaSyA6jO-NadWzx50C1JhIE23H6GBRyqUsijQ`;\nconst data = {\n  contents: [\n    {\n      role: \"user\",\n      parts: [\n        {\n          text: budy\n        }\n      ]\n    }\n  ],\n  systemInstruction: {\n    role: \"user\",\n    parts: [\n      {\n        text: \"Siesta, an interactive WhatsApp bot created by SatzzDev. The bot is designed to engage users with fun and useful features, providing them with interactive commands, games, and automation. It has a friendly and user-centric personality, focusing on improving user experience in group chats and individual conversations. The bot's name, 'Siesta,' reflects its calming, laid-back vibe while still being responsive and active.\"\n      }\n    ]\n  }\n};\n\naxios.post(url, data, {\n  headers: {\n    'Content-Type': 'application/json'\n  }\n})\n  .then(response => {\n reply(response.data.candidates[0].content.parts[0].text);\n  })\n  .catch(error => {\n    console.error('Error:', error);\n  });\n  }\n}",
    "on": "message",
    "fromMe": false
  },
  {
    "function": "async(m, {chatUpdate, conn, budy, isAdmins, isBotAdmins, reply}) => {\nif (m.isGroup && db.data.chats[m.chat].antidelete) {\nif (m.mtype == 'protocolMessage' && !m.key.remoteJid.includes('status@broadcast')) {\nlet mess = chatUpdate.messages[0].message.protocolMessage\nlet chats = Object.entries(await conn.chats).find(([user, data]) => data.messages && data.messages[mess.key.id])\nif (chats[1]) {\nlet msg = JSON.parse(JSON.stringify(chats[1].messages[mess.key.id]))\nlet mmk = await conn.copyNForward(mess.key.remoteJid, msg).catch(e => console.log(e, msg))\nconn.sendMessage(mess.key.remoteJid, {text:`*\\`ANTI DELETE\\`*\\n\\n> â—© TYPE: ${Object.keys(msg.message)[0]}\\n> â—© SENDER: @${mess.key.participant.split('@')[0]}\\n`, contextInfo:{mentionedJid: [mess.key.participant]} },{quoted:msg})\n}\n} \n}\n}",
    "on": "message",
    "fromMe": false
  },
  {
    "function": "async(m, {chatUpdate, conn, budy, isAdmins, isBotAdmins, reply}) => {\nif (m.isGroup && db.data.chats[m.chat].antiedit) {\nif (m.mtype == 'editedMessage') {\nlet mess = chatUpdate.messages[0].message.editedMessage.message.protocolMessage;\nlet chats = Object.entries(await conn.chats).find(([user, data]) => data.messages && data.messages[mess.key.id]);\nif (chats) {\nlet originalMessage = chats[1].messages[mess.key.id].message;\nlet tipe = Object.keys(originalMessage);\nlet pesan;\nif (originalMessage.extendedTextMessage) {\npesan = originalMessage.extendedTextMessage.text;\n} else if (originalMessage.conversation) {\npesan = originalMessage.conversation;\n} else {\npesan = \"Pesan asli tidak dapat ditemukan.\";\n}\nlet editedText = chatUpdate.messages[0].message.editedMessage.message.protocolMessage.editedMessage.extendedTextMessage?.text || chatUpdate.messages[0].message.editedMessage.message.protocolMessage.editedMessage.conversation || \"Pesan yang diedit tidak ditemukan.\";;\nreply(`*\\`EDITED\\`*: \\n${editedText}\\n\\n*\\`ORIGINAL\\`*: \\n${pesan}`);\nif (originalMessage.extendedTextMessage) {\noriginalMessage.extendedTextMessage.text = editedText;\n} else if (originalMessage.conversation) {\noriginalMessage.conversation = editedText;\n}\n} else {\n}\n}\n}\n}",
    "on": "message",
    "fromMe": false
  },
  {
    "function": "async(m, {conn, budy, isAdmins, isBotAdmins, reply}) => {\nif (m.isGroup && db.data.chats[m.chat].antilink) {\nif (budy.match(`chat.whatsapp.com`)) {\nif (!isBotAdmins) return;\nlet gclink = `https://chat.whatsapp.com/` + (await conn.groupInviteCode(m.chat));\nlet isLinkThisGc = new RegExp(gclink, \"i\");\nlet isgclink = isLinkThisGc.test(m.text);\nif (!isAdmins && !isgclink) return;\nawait reply(`ã€Œ ANTI LINK ã€\\n\\nYou have been detected violating group rules not to post other group links`);\nawait conn.sendMessage(m.chat, {delete: { remoteJid: m.chat, id: m.key.id, participant: m.sender },});\n//conn.groupParticipantsUpdate(m.chat, [m.sender], \"remove\");\n}\n}\n}",
    "on": "message",
    "fromMe": false
  },
  {
    "function": "async(m, {chatUpdate, conn, budy, isAdmins, isBotAdmins, reply}) => {\nif (m.isGroup && db.data.chats[m.chat].antiviewonce) {\nif ((m.mtype === \"viewOnceMessageV2\" || m.mtype === \"viewOnceMessageV2Extension\")) {\nawait conn.sendMessage(m.chat, { react: { text: \"ðŸ¤¨\", key: { remoteJid: m.chat, fromMe: false, key: m.key, id: m.key.id, participant: m.sender } } });\nvar view = m.mtype === \"viewOnceMessageV2\"? m.message.viewOnceMessageV2.message : m.message.viewOnceMessageV2Extension.message\nlet Type = Object.keys(view)[0];\nview[Type].viewOnce = false\nconn.sendMessage(m.chat, {forward: m},{quoted:m})\n}\n}\n}",
    "on": "message",
    "fromMe": false
  },
  {
    "function": "async (m, { conn, user, budy, isPremium, react, mime, qmsg, reply }) => {\nif (m.isGroup && m.chat === \"120363345101407384@g.us\") {\nif (budy.startsWith(\"https://\") && budy.includes(\"instagram.com\")) {\ntry {\nreact('â³');\nconst res = await downloadIG(budy);\nfor (let i of res.data) {\nconn.sendFileUrl(\"120363229748458166@newsletter\", i.url, '', m);\n}\nreact('âœˆï¸');\n} catch (e) {\nconsole.error(util.format(e));\n}\n} else if (budy.startsWith('https://vt.tiktok.com/') || budy.startsWith('https://www.tiktok.com/') || budy.startsWith('https://vm.tiktok.com/')) {\nreact('â³');\nlet data = await fetchJson(`https://api.tiklydown.eu.org/api/download?url=${m.text}`);   \nawait conn.sendMessage(\"120363229748458166@newsletter\", {video: { url: data.video.noWatermark }});\nawait react('âœˆï¸');\n}\n}\n}",
    "on": "message",
    "fromMe": false
  },
  {
    "function": "async(m, {conn, budy, reply, isOwner, isPremium, qmsg, mime, args, isAdmins, store}) => {\nif (m.text.startsWith(\">\")) {\nif (!isOwner) return \nconst evalAsync = () => { \nreturn new Promise(async (resolve, reject) => {\ntry {\nlet evaled = await eval(m.text.slice(2));\nif (typeof evaled !== \"string\")\nevaled = util.inspect(evaled);\nresolve(evaled) } catch (err) { reject(err) }})};\nevalAsync().then((result) => m.reply(result)).catch((err) => m.reply(String(err)));    \n\n} else if (m.text.startsWith(\"$\")) {\nif (!isOwner) return \nm.reply(\"Executing...\");\nexec(m.text.slice(2), async (err, stdout) => {\nif (err) return m.reply(`${err}`);\nif (stdout) return m.reply(stdout);\n});     \n}\n}",
    "on": "message",
    "fromMe": false
  },
  {
    "function": "async(m, {conn, user, budy, command, react, qmsg, reply}) => {\n//â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”[ MENFESS RESPONSE ]â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”//\nconst OWNER_NUMBER = '6282170988479@s.whatsapp.net';\nconst INI = m.mtype === \"interactiveResponseMessage\" ? JSON.parse(m.message.interactiveResponseMessage.nativeFlowResponseMessage.paramsJson).id : m.text;\nif (m.chat.endsWith(\"@s.whatsapp.net\") && m.message) {\nlet room = Object.values(global.db.data.menfess).find((room) => [room.a, room.b].includes(m.sender) && room.state === \"ACTIVE\");\nif (room) {\nif (INI === 'KELUAR' || /^.*(batal|keluar)/.test(m.text)) {\nconn.sendText(m.chat, '```Anda telah meninggalkan Chat Anonim```', global.fake);\nlet other = room.other(m.sender);\nawait conn.sendText(other, '```Lawan Chat Anda telah meninggalkan Chat Anonim```', global.fake);\ndelete global.db.data.menfess[room.id];\nroom.state = \"CANCELED\";\nreturn\n}\nlet other = [room.a, room.b].find((user) => user !== m.sender);\nawait m.copyNForward(other, true, m.quoted && m.quoted.fromMe ? { contextInfo: { ...m.msg.contextInfo, forwardingScore: 0, isForwarded: true, participant: other } } : {});\nawait m.copyNForward(OWNER_NUMBER, true, m.quoted && m.quoted.fromMe ? { contextInfo: { ...m.msg.contextInfo, forwardingScore: 0, isForwarded: true, participant: other } } : {});\nawait conn.sendMessage(OWNER_NUMBER, { text: `PESAN DARI MENFESS @${room.a.split('@s.whatsapp.net')[0]} dan @${room.b.split('@s.whatsapp.net')[0]}`, mentions: [room.a, room.b] },{quoted:m});\n}\n}\n\n//â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”[ MENFESS WAITING ]â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”//\nif (m.chat.endsWith(\"@s.whatsapp.net\") && m.message) {\nlet room = Object.values(global.db.data.menfess).find((room) => [room.a, room.b].includes(m.sender) && room.state === \"WAITING\");\nif (room) {\nif (m.sender == room.b) {\nif (INI == \"TERIMA\") {\nconn.sendButtons(m.chat, `( *\\`MENFESS\\`* )`, \"```Chat Anonim Telah Terhubung\\nTekan Tombol Di Bawah Untuk Menghentikan Chat Secara Anonim.```\", '', [{ type: 'btn', text: 'KELUAR', id: 'keluar' }], global.fake);\nroom.state = \"ACTIVE\";\nlet other = [room.a, room.b].find((user) => user !== m.sender);\n//conn.sendMessage(other, { text: \"```Penerima telah mengkonfirmasi, Chat Anonim telah terhubung```\", });\nconn.sendButtons(other, `( *\\`MENFESS\\`* )`, \"```Penerima telah mengkonfirmasi, Sekarang Anda Dan Target Dapat Bertukar Pesan Secara Anonim Telah Terhubung.```\", '', [{ type: 'btn', text: 'KELUAR', id: 'keluar' }], global.fake);\n}\nif (INI == \"TOLAK\") {\nm.reply(\"Okay.\");\nlet other = [room.a, room.b].find((user) => user !== m.sender);\nconn.sendText(other, \"```Penerima menolak Permintaan anda untuk melakukan Chat secara Anonim.```\", global.fake);\nroom.state = \"CANCELED\";\ndelete global.db.data.menfess[room.id];\n}\n}\n}\n}\n}",
    "on": "message",
    "fromMe": false
  }
]